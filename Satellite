#include <SoftwareSerial.h>
#include <DHT.h>
#include <Servo.h>
#ifndef CHECKSUM_H
#define CHECKSUM_H
#include <stdint.h>
#include <stddef.h>
#endif
#include <string.h>
#include <stdio.h>


// -------------------- DHT SENSOR --------------------
#define DHTPIN 2
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

// -------------------- SERVO -------------------------
Servo servoMotor; 
int angulo = 90;

// -------------------- TIMERS ------------------------
long nextMillis1;
long nextMillis2;
const long interval1 = 3000;
const long interval2 = 5000;
unsigned long nextImpresion;
unsigned long nextTimeoutHT;
int intervaloImpresion = 2000;

// -------------------- ORBIT CONSTANTS ----------------
const double G = 6.67430e-11;
const double M = 5.97219e24;
const double R_EARTH = 6371000;
const double ALTITUDE = 400000;
const double EARTH_ROTATION_RATE = 7.2921159e-5;
const unsigned long MILLIS_BETWEEN_UPDATES = 1000;
const double TIME_COMPRESSION = 90.0;

unsigned long nextUpdate;
double real_orbital_period;
double r;

double orbX = 0;
double orbY = 0;
double orbZ = 0;

// -------------------- DATA SENDING -------------------
int Pausa2 = 0;
int modo_Media_temperatura = 0;
float temperaturas[100];
float suma = 0;
float m = 0;
int i = 0;

// -------------------- ULTRASONIC ---------------------
const int trigPin = 4;
const int echoPin = 5;
float duration;
float distance;

// -------------------- JOYSTICK + SERVO ---------------
int aut = 1;
int valX = 0;
int joyX = A0;
float velMotor = 0;
int pinBoton = 3;
bool botonAnterior = HIGH;
int sentido = 0;
//nose
float t, h;

//Errores
bool esperandoTimeout = true;
bool fallo_TyH = 0;
bool fallo_tiempo = 0;
bool fallo_cerca = 0;
// -------------------- SERIAL -------------------------
String input = "";
SoftwareSerial mySerial(10, 11); // RX, TX
// Before Setup Se crea una funcion para enviar todos los datos de una

void enviar_datos_completos(float t, float h, float distance, int angulo, float m,
                            double x, double y, double z, float fallo_TyH, float fallo_cerca) {
    mySerial.print("1:"); mySerial.print(t);
    mySerial.print(":2:"); mySerial.print(h);
    mySerial.print(":3:"); mySerial.print(distance);
    mySerial.print(":4:"); mySerial.print(angulo);

    // canvi aquí
    if (modo_Media_temperatura == 1) {
        mySerial.print(":5:"); mySerial.print(m);   // envia la mitjana calculada al satèl·lit
    } else {
        mySerial.print(":5:"); mySerial.print(m); // envia NaN si la mitjana es calcula a terra
    }

    mySerial.print(":6:"); mySerial.print(x);
    mySerial.print(":7:"); mySerial.print(y);
    mySerial.print(":8:"); mySerial.println(z);
    mySerial.print(":9:"); mySerial.print(fallo_TyH);
    mySerial.print(":10:"); mySerial.println(fallo_cerca);
}

float leerDistancia() {//Funcion para leer la distancia
  long duracion;
  float distancia;
  // Intentos
  for (int intento = 0; intento < 3; intento++) {
    digitalWrite(trigPin, LOW);
    delayMicroseconds(3);
    digitalWrite(trigPin, HIGH);
    delayMicroseconds(10);
    digitalWrite(trigPin, LOW);
    duracion = pulseIn(echoPin, HIGH, 30000); // 30 ms
    if (duracion > 0) {
      distancia = duracion * 0.0343 / 2.0;
      // filtrar basura
      if (distancia > 2 && distancia < 400) {
        return distancia;
      }
    }
    delay(20); // Pequeño descanso
    return distancia;
  }
  return -1; // todas fallaron
}
int q = 0;
//Funciones checksum//
int Checksum(char misatge[8]){
        int i=0;
        int suma=0;
    while (misatge[i]!='\0'){
        suma =suma+misatge[i];
        i++;
    }
        suma = suma%256;
        return suma;
    }
int Comprueva(char frase[],int resposta){
        int suma =0;
        int i =0;
    while (frase[i]!='\0'){
        suma =suma+frase[i];
        i++;
    }
    if (suma%256==resposta)
        return 1;
    else
        return 0;
    }
// ======================================================
//                        SETUP
// ======================================================
void setup() {
    Serial.begin(9600);
    mySerial.begin(9600);
    mySerial.println("Empezamos");

    // timers
    nextMillis1 = millis() + interval1;
    nextMillis2 = millis() + interval2;
    nextImpresion = millis() + intervaloImpresion;

    // DHT
    dht.begin();

    // Servo
    servoMotor.attach(6);
    servoMotor.write(angulo);

    // Ultrasonic
    pinMode(trigPin, OUTPUT);
    pinMode(echoPin, INPUT);

    // Joystick button
    pinMode(pinBoton, INPUT_PULLUP);
    pinMode(3, OUTPUT);

    // Orbit simulation setup
    r = R_EARTH + ALTITUDE;
    real_orbital_period = 2 * PI * sqrt(pow(r, 3) / (G * M));
    nextUpdate = MILLIS_BETWEEN_UPDATES;
}

// ======================================================
//                         LOOP
// ======================================================
void loop() {

    // --------------------------------------------------
    //  SENSOR + DATA SENDING  every interval1
    // --------------------------------------------------
    if (Pausa2 == 0 && millis() >= nextMillis1) {

        h = dht.readHumidity();
        t = dht.readTemperature();

        if (isnan(h) || isnan(t)) {//Si h o t da nan enviar error
            esperandoTimeout = true;
        } else {
            esperandoTimeout = false;
            fallo_TyH = 0; // Se recuperó
            nextTimeoutHT = millis() + 5000;
            temperaturas[i] = t;

            // media móvil 10 valores
            if (modo_Media_temperatura == 1) {

                if (i > 9) {
                    suma = suma + temperaturas[i] - temperaturas[(i - 9)];
                    m = suma / 10.0;
                } 
                else {
                    suma += temperaturas[i];
                    m = suma / 10.0;
            }
        }

        i++;
        }
        nextMillis1 = millis() + interval1;
    }
    if (esperandoTimeout && (millis() >= nextTimeoutHT)) {
    fallo_TyH = 1; // Aquí sí se activa la alarma
    }

    // --------------------------------------------------
    //      ORBIT SIMULATION UPDATE
    // --------------------------------------------------
    unsigned long currentTime = millis();
    if (currentTime > nextUpdate) {
        simulate_orbit(currentTime, 0, 0);
        nextUpdate = currentTime + MILLIS_BETWEEN_UPDATES;
    }

    // --------------------------------------------------
    //                SERVO MANUAL MODE
    // --------------------------------------------------
    if (!aut) {
        valX = analogRead(joyX);
        velMotor = abs(((valX - 500) / 500.00) * 4.00);

        if (valX < 490 && angulo < 180) angulo += velMotor;
        else if (valX > 510 && angulo > 0) angulo -= velMotor;

        angulo = constrain(angulo, 0, 180);
    }

    // --------------------------------------------------
    //                SERVO AUTOMATIC MODE
    // --------------------------------------------------
    else {
        if (angulo >= 180) sentido = 0;
        if (angulo <= 0) sentido = 1;

        if (sentido == 0) angulo -= 2;
        else angulo += 2;
    }

    // ---- SENSOR ULTRASONICO ----
  distance = leerDistancia(); //Detetca si hay un error y si no envia distancia
  if (distance == -1) {
    Serial.println("Lectura ultrasónica inválida");
    fallo_cerca = 0; // No marcar error de cercanía
  } else if (distance < 10) {
    fallo_cerca = 1;
  } else {
    fallo_cerca = 0;
  }

    servoMotor.write(angulo);
     // ---- IMPRIMIR ----
  if (millis() >= nextImpresion) {

    // ---- COMUNICACION ----
        enviar_datos_completos(t, h, distance, angulo, m, orbX, orbY, orbZ,fallo_TyH,fallo_cerca);
        q++;
    nextImpresion = millis() + intervaloImpresion;
    }

// --------------------------------------------------
//                SERIAL COMMANDS 
// --------------------------------------------------
if (mySerial.available()) { 

     String input = mySerial.readStringUntil('\n');
    input.trim();
    Serial.println(input);

    // Convertir String → char[]
    char buf[100];
    input.toCharArray(buf, 100);

    int suma = Checksum(buf);
    Serial.print("Checksum calculado: ");
    Serial.println(suma);

    if (Comprueva(buf, suma))
        Serial.println("El checksum coincide");
    else
        Serial.println("El checksum NO coincide");

    int firstColon = input.indexOf(':');
    if (firstColon == -1) {
        Serial.println("Formato inválido. Use LABEL:VALOR");
        return;
    }

    String label = input.substring(0, firstColon);
    String valueStr = input.substring(firstColon + 1);
    valueStr.trim();

    // -------------------------------
    //        SWITCH BY LABEL
    // -------------------------------
    if (label == "1") {
        int v = valueStr.toInt();
        Pausa2 = v;
        Serial.println(v ? "Parar" : "Reanudar");
    }

    else if (label == "2") {
        if (valueStr == "1") {
            modo_Media_temperatura = 1;
            Serial.println("Satelite");
        } 
        else if (valueStr == "0") {
            modo_Media_temperatura = 0;
            Serial.println("Tierra");
        }
        else {
            Serial.println("Valor MODO_TEMP desconocido");
        }
    }

    else if (label == "AUT") {
        int v = valueStr.toInt();
        aut = v;
        Serial.println(v ? "Modo auto" : "Modo manual");
    }

    else if (label == "ANGULO") {
        angulo = valueStr.toInt();
        Serial.print("Ángulo recibido: ");
        Serial.println(angulo);
    }

    else {
        Serial.print("Comando no reconocido: ");
        Serial.println(input);
    }
}
}

// ======================================================
//                  ORBIT SIMULATION FUNC
// ======================================================
void simulate_orbit(unsigned long millis, double inclination, int ecef) {//simula la orbita

    double time = (millis / 1000) * TIME_COMPRESSION;
    double angle = 2 * PI * (time / real_orbital_period);

    orbX = r * cos(angle);
    orbY = r * sin(angle) * cos(inclination);
    orbZ = r * sin(angle) * sin(inclination);

    if (ecef) {
        double theta = EARTH_ROTATION_RATE * time;
        double x_ecef = orbX * cos(theta) - orbY * sin(theta);
        double y_ecef = orbX * sin(theta) + orbY * cos(theta);
        orbX = x_ecef;
        orbY = y_ecef;
    }
}
