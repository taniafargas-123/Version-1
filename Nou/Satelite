#include <SoftwareSerial.h>
#include <DHT.h>
#include <Servo.h>
#ifndef CHECKSUM_H
#define CHECKSUM_H
#include <stdint.h>
#include <stddef.h>
#endif
#include <string.h>
#include <stdio.h>


// -------------------- DHT SENSOR --------------------
#define DHTPIN 2
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

// -------------------- SERVO -------------------------
Servo servoMotor; 
int angulo = 90;

// -------------------- TIMERS ------------------------
long nextMillis1;
long nextMillis2;
long interval1 = 3000;
long interval2 = 5000;
unsigned long nextImpresion;
unsigned long nextTimeoutHT;
int intervaloImpresion = 2000;

// -------------------- ORBIT CONSTANTS ----------------
const double G = 6.67430e-11;
const double M = 5.97219e24;
const double R_EARTH = 6371000;
const double ALTITUDE = 400000;
const double EARTH_ROTATION_RATE = 7.2921159e-5;
const unsigned long MILLIS_BETWEEN_UPDATES = 1000;
const double TIME_COMPRESSION = 90.0;

unsigned long nextUpdate;
double real_orbital_period;
double r;

double orbX = 0;
double orbY = 0;
double orbZ = 0;

// -------------------- DATA SENDING -------------------
int Pausa2 = 1;
int modo_Media_temperatura = 0;
float temperaturas[100];
float suma = 0;
float m = 0;
int i = 0;

// -------------------- ULTRASONIC ---------------------
const int trigPin = 4;
const int echoPin = 5;
float duration;
float distance;

// -------------------- JOYSTICK + SERVO ---------------
int aut = 1;
int valX = 0;
int joyX = A0;
float velMotor = 0;
int pinBoton = 3;
bool botonAnterior = HIGH;
int sentido = 0;
//nose
float t, h;

//Errores
bool esperandoTimeout = true;
bool fallo_TyH = 0;
bool fallo_tiempo = 0;
bool fallo_cerca = 0;
// -------------------- SERIAL -------------------------
String input = "";
SoftwareSerial mySerial(10, 11); // RX, TX
// Before Setup Se crea una funcion para enviar todos los datos de una


float leerDistancia() {//Funcion para leer la distancia
  long duracion;
  float distancia;
  // Intentos
  for (int intento = 0; intento < 3; intento++) {
    digitalWrite(trigPin, LOW);
    delayMicroseconds(3);
    digitalWrite(trigPin, HIGH);
    delayMicroseconds(10);
    digitalWrite(trigPin, LOW);
    duracion = pulseIn(echoPin, HIGH, 30000); // 30 ms
    if (duracion > 0) {
      distancia = duracion * 0.0343 / 2.0;
      // filtrar basura
      if (distancia > 2 && distancia < 400) {
        return distancia;
      }
    }
    delay(20); // Pequeño descanso
    return distancia;
  }
  return -1; // todas fallaron
}
int q = 0;
//Funciones checksum//

// ======================================================
//                        SETUP
// ======================================================
void setup() {
    Serial.begin(9600);
    mySerial.begin(9600);
    mySerial.println("Empezamos");

    // timers
    nextMillis1 = millis() + interval1;
    nextMillis2 = millis() + interval2;
    nextImpresion = millis() + intervaloImpresion;

    // DHT
    dht.begin();

    // Servo
    servoMotor.attach(6);
    servoMotor.write(angulo);

    // Ultrasonic
    pinMode(trigPin, OUTPUT);
    pinMode(echoPin, INPUT);

    // Joystick button
    pinMode(pinBoton, INPUT_PULLUP);
    pinMode(3, OUTPUT);

    // Orbit simulation setup
    r = R_EARTH + ALTITUDE;
    real_orbital_period = 2 * PI * sqrt(pow(r, 3) / (G * M));
    nextUpdate = MILLIS_BETWEEN_UPDATES;
}

// ======================================================
//                         LOOP
// ======================================================
void loop() {

    // --------------------------------------------------
    //  SENSOR + DATA SENDING  every interval1
    // --------------------------------------------------
    if (Pausa2 == 0 && millis() >= nextMillis1) {
        h = dht.readHumidity();
        t = dht.readTemperature();

        if (isnan(h) || isnan(t)) {//Si h o t da nan enviar error
            esperandoTimeout = true;
            Serial.print("Error");
        } else {
            esperandoTimeout = false;
            fallo_TyH = 0; // Se recuperó
            nextTimeoutHT = millis() + 5000;
            temperaturas[i] = t;

            // media móvil 10 valores
            if (modo_Media_temperatura == 1) {

                if (i > 9) {
                    suma = suma + temperaturas[i] - temperaturas[(i - 9)];
                    m = suma / 10.0;
                } 
                else {
                    suma += temperaturas[i];
                    m = suma / 10.0;
                }
            }
            mySerial.print("TEMP:"); mySerial.println(t);
            mySerial.print("HUM:"); mySerial.println(h);

            if (modo_Media_temperatura == 1) {
                mySerial.print("MED:"); mySerial.print(m);   // envia la mitjana calculada al satèl·lit
            } else {
                mySerial.print("MED:"); mySerial.print(m); // envia NaN si la mitjana es calcula a terra
            }
        i++;
        }
        nextMillis1 = millis() + interval1;
    }
    if (esperandoTimeout && (millis() >= nextTimeoutHT)) {
    fallo_TyH = 1; // Aquí sí se activa la alarma
    }

    // --------------------------------------------------
    //      ORBIT SIMULATION UPDATE
    // --------------------------------------------------
    unsigned long currentTime = millis();
    if (currentTime > nextUpdate) {
        simulate_orbit(currentTime, 0, 0);
        nextUpdate = currentTime + MILLIS_BETWEEN_UPDATES;
    }

    // --------------------------------------------------
    //                SERVO MANUAL MODE
    // --------------------------------------------------
    if (!aut) {
        valX = analogRead(joyX);
        velMotor = abs(((valX - 500) / 500.00) * 4.00);

        if (valX < 490 && angulo < 180) angulo += velMotor;
        else if (valX > 510 && angulo > 0) angulo -= velMotor;

        angulo = constrain(angulo, 0, 180);
    }

    // --------------------------------------------------
    //                SERVO AUTOMATIC MODE
    // --------------------------------------------------
    else {
        if (angulo >= 180) sentido = 0;
        if (angulo <= 0) sentido = 1;

        if (sentido == 0) angulo -= 2;
        else angulo += 2;
    }

    // ---- SENSOR ULTRASONICO ----
    if (Pausa2 == 0 && millis() >= nextMillis2){
        distance = leerDistancia(); //Detetca si hay un error y si no envia distancia
        if (distance == -1) {
            Serial.println("Lectura ultrasónica inválida");
            fallo_cerca = 0; // No marcar error de cercanía
        } else if (distance < 10) {
            fallo_cerca = 1;
        } else {
            fallo_cerca = 0;
        }
        mySerial.print("DIST:"); mySerial.println(distance);
        mySerial.print("ANG:"); mySerial.println(90);

        nextMillis2 = millis() + interval2;
    }

    servoMotor.write(angulo);
     // ---- IMPRIMIR ----

// --------------------------------------------------
//                SERIAL COMMANDS 
// --------------------------------------------------
if (mySerial.available()) { 

    String input = mySerial.readStringUntil('\n');
    input.trim();
    Serial.println(input);

    int firstColon = input.indexOf(':');
    if (firstColon == -1) {
        Serial.println("Formato inválido. Use LABEL:VALOR");
        return;
    }

    String label = input.substring(0, firstColon);
    String valueStr = input.substring(firstColon + 1);
    valueStr.trim();

    // -------------------------------
    //        SWITCH BY LABEL
    // -------------------------------
    if (label == "1") {
        if (valueStr == "1") {
            Pausa2 = 1;
            Serial.println("Pausar");
        } 
        else if (valueStr == "0") {
            Pausa2 = 0;
            Serial.println("Reanudar");
        }
    }
    else if (label == "2") {
        if (valueStr== "1") {
            modo_Media_temperatura = 1;
            Serial.println("Satelite");
        } 
        else if (valueStr == "0") {
            modo_Media_temperatura = 0;
            Serial.println("Tierra");
        }
        else {
            Serial.println("Valor MODO_TEMP desconocido");
        }
    }

    else if (label == "AUT") {
        int v = valueStr.toInt();
        aut = v;
        Serial.println(v ? "Modo auto" : "Modo manual");
    }

    else if (label == "ANGULO") {
        angulo = valueStr.toInt();
        Serial.print("Ángulo recibido: ");
        Serial.println(angulo);
    }
    else if (label =="3") {
        interval1 = (valueStr.toInt()*1000);
        Serial.print("Periodo temperatura recibido:");
        Serial.println(interval1);
    }
    else if (label =="4") {
        interval2 = (valueStr.toInt()*1000);
        Serial.print("Periodo distancia recibido:");
        Serial.println(interval2);
    }

    else {
        Serial.print("Comando no reconocido: ");
        Serial.println(input);
    }
}
}


// ======================================================
//                  ORBIT SIMULATION FUNC
// ======================================================
void simulate_orbit(unsigned long millis, double inclination, int ecef) {//simula la orbita

    double time = (millis / 1000) * TIME_COMPRESSION;
    double angle = 2 * PI * (time / real_orbital_period);

    orbX = r * cos(angle);
    orbY = r * sin(angle) * cos(inclination);
    orbZ = r * sin(angle) * sin(inclination);

    if (ecef) {
        double theta = EARTH_ROTATION_RATE * time;
        double x_ecef = orbX * cos(theta) - orbY * sin(theta);
        double y_ecef = orbX * sin(theta) + orbY * cos(theta);
        orbX = x_ecef;
        orbY = y_ecef;
    }
}
