#include <SoftwareSerial.h>
#include <DHT.h>
#include <Servo.h>
#ifndef CHECKSUM_H
#define CHECKSUM_H
#include <stdint.h>
#include <stddef.h>
#endif
#include <string.h>
#include <stdio.h>


// -------------------- DHT SENSOR --------------------
#define DHTPIN 2
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

// -------------------- SERVO -------------------------
Servo servoMotor; 
int angulo = 90;

// -------------------- TIMERS ------------------------
long nextMillis1;
long nextMillis2;
long interval1 = 3000;
long interval2 = 5000;
unsigned long nextImpresion;
unsigned long nextTimeoutHT;
int intervaloImpresion = 2000;

// -------------------- ORBIT CONSTANTS ----------------
const double G = 6.67430e-11;
const double M = 5.97219e24;
const double R_EARTH = 6371000;
const double ALTITUDE = 400000;
const double EARTH_ROTATION_RATE = 7.2921159e-5;
const unsigned long MILLIS_BETWEEN_UPDATES = 1000;
const double TIME_COMPRESSION = 90.0;

unsigned long nextUpdate;
double real_orbital_period;
double r;

double orbX = 0;
double orbY = 0;
double orbZ = 0;

// -------------------- DATA SENDING -------------------
int Pausa2 = 1;
int modo_Media_temperatura = 0;
float temperaturas[100];
float suma = 0;
float m = 0;
int i = 0;

// -------------------- ULTRASONIC ---------------------
const int trigPin = 4;
const int echoPin = 5;
float duration;
float distance;
float a;
int q;

// -------------------- JOYSTICK + SERVO ---------------
int aut = 1;
int valX = 0;
int joyX = A0;
float velMotor = 0;
int pinBoton = 3;
bool botonAnterior = HIGH;
int sentido = 0;
//nose
float t, h;

//Errores
bool esperandoTimeout = true;
bool fallo_TyH = 0;
bool fallo_tiempo = 0;
bool fallo_cerca = 0;
// -------------------- SERIAL -------------------------
String input = "";
SoftwareSerial mySerial(10, 11); // RX, TX
// Before Setup Se crea una funcion para enviar todos los datos de una

//==============================================================================================================
//                                               FUNCIONES
//==============================================================================================================

// --------------- FUNCION DE SIMULACION DE ORBITA -----------------

void simulate_orbit(unsigned long millis, double inclination, int ecef) {//simula la orbita

    double time = (millis / 1000) * TIME_COMPRESSION;
    double angle = 2 * PI * (time / real_orbital_period);

    orbX = r * cos(angle);
    orbY = r * sin(angle) * cos(inclination);
    orbZ = r * sin(angle) * sin(inclination);

    if (ecef) {
        double theta = EARTH_ROTATION_RATE * time;
        double x_ecef = orbX * cos(theta) - orbY * sin(theta);
        double y_ecef = orbX * sin(theta) + orbY * cos(theta);
        orbX = x_ecef;
        orbY = y_ecef;
    }
}

// --------------- FUNCION DE LECTURA DE DISTANCIA -----------------

float leerDistancia() {
  long duracion;
  float distancia;
  float a;
  int q = 0;
  //  se hac
  for (int intento = 0; intento < 3; intento++) {
    // 1. Lee la duración
    digitalWrite(trigPin, LOW);
    delayMicroseconds(3);
    digitalWrite(trigPin, HIGH);
    delayMicroseconds(10);
    digitalWrite(trigPin, LOW);
    duracion = pulseIn(echoPin, HIGH, 30000); // 30 ms
    if (duracion > 0) {
        // 2. Calcula la distancia
      distancia = duracion * 0.0343 / 2.0; 
      if (distancia > 2 && distancia < 400) {
        a += distancia;
        q++;
      }
    } else {
        distancia = 0;
    }
  }
  // 3. Hace la media
  if (distancia > 3){
    if (q == 0){
        q = 1;
    }
    return a/q;
  } else {
    return -1;
  }
}

// =============================================================================================================
//                                                  SETUP
// =============================================================================================================
void setup() {
    Serial.begin(9600); // Ordenador (NO REALIDAD)
    mySerial.begin(9600); // LoRa
    mySerial.println("Empezamos");

    // timers
    nextMillis1 = millis() + interval1;
    nextMillis2 = millis() + interval2;

    // DHT
    dht.begin();

    // Servo
    servoMotor.attach(6);
    servoMotor.write(angulo);

    // Ultrasonic
    pinMode(trigPin, OUTPUT);
    pinMode(echoPin, INPUT);

    // Boton del Joystick
    pinMode(pinBoton, INPUT_PULLUP);
    pinMode(3, OUTPUT);

    // Orbit simulation setup
    r = R_EARTH + ALTITUDE;
    real_orbital_period = 2 * PI * sqrt(pow(r, 3) / (G * M));
    nextUpdate = MILLIS_BETWEEN_UPDATES;
}

// ============================================================================================================
//                                                      LOOP
// ============================================================================================================
void loop() {

    // --------------------------------------------------
    //      1. Lectura de temperatura & humedad
    // --------------------------------------------------
    if (Pausa2 == 0 && millis() >= nextMillis1) {
        h = dht.readHumidity();
        t = dht.readTemperature(); // Lectura de datos

        if (isnan(h) || isnan(t)) {  // Si H o T son NaN, empieza un temporizador para dar error
            esperandoTimeout = true; 
            Serial.print("Error");
        } else {
            esperandoTimeout = false;
            fallo_TyH = 0; // En caso de que el fallo estuviera activo, se desactiva
            nextTimeoutHT = millis() + 5000;
            temperaturas[i] = t; // Como un .append en python

            // media móvil 10 valores
            if (modo_Media_temperatura == 1) { // En este caso se calcula la media en esta estacion

                if (i > 9) { // Aun no hay 10 temperaturas
                    suma = suma + temperaturas[i] - temperaturas[(i - 9)]; // Se van agregando las temperaturas al calulo de media
                    m = suma / 10.0;
                } 
                else { // Ya hay 10 temperaturas
                    suma += temperaturas[i];
                    m = suma / 10.0;
                }
            }
            mySerial.print("TEMP:"); mySerial.println(t); // Se envian T, H, y la media a la estacion de tierra
            mySerial.print("HUM:"); mySerial.println(h);
            mySerial.print("MED:"); mySerial.print(m);  
            i++; // Pasa al siguiente instante de temperatura
        }
        nextMillis1 = millis() + interval1;
    }

    //---------------------------------------------------
    //      2. Activador de alarma de T y H
    // --------------------------------------------------
    if (esperandoTimeout && (millis() >= nextTimeoutHT)) {
        fallo_TyH = 1; // Aquí sí se activa la alarma
    }

    // --------------------------------------------------
    //      3. Actualización de simulador de la orbita
    // --------------------------------------------------
    unsigned long currentTime = millis();
    if (currentTime > nextUpdate) {
        simulate_orbit(currentTime, 0, 0);
        nextUpdate = currentTime + MILLIS_BETWEEN_UPDATES;
    }

    // --------------------------------------------------
    //          4. Modo manual del servo
    // --------------------------------------------------
    if (!aut) {
        valX = analogRead(joyX);
        velMotor = abs(((valX - 500) / 500.00) * 4.00); // La velocidad depende de cuanto se tumba el joystick

        if (valX < 490 && angulo < 180) angulo += velMotor; // Evitar valores falsos del joystick drift
        else if (valX > 510 && angulo > 0) angulo -= velMotor;

        angulo = constrain(angulo, 0, 180); // Conversor de un numero de 0 a 1023 a uno de entre 0 y 180
    }

    // --------------------------------------------------
    //          4'1. Modo automatico del servo
    // --------------------------------------------------
    else {
        if (angulo >= 180) sentido = 0; 
        if (angulo <= 0) sentido = 1; // Si se pasa de 0  o de 180 vuelve al intervalo (0-180)

        if (sentido == 0) angulo -= 2;
        else angulo += 2; // El sentido determina hacia que lado giran, en este modo con velocidad constante
    }

    // --------------------------------------------------
    //          4'2. Actualización del angulo
    // --------------------------------------------------
    servoMotor.write(angulo);

    // --------------------------------------------------
    //        5. Detección de fallo de distancia
    // --------------------------------------------------
    if (Pausa2 == 0 && millis() >= nextMillis2){
        distance = leerDistancia(); //Detetca si hay un error y si no envia distancia
        if (distance == -1) {
            Serial.println("Lectura ultrasónica inválida");
            fallo_cerca = 0; // No marcar error de cercanía en caso de error de lectura. IMPORTANTE
        } else if (distance < 10) {
            fallo_cerca = 1; // Si hay un objeto a menos de 10 cm, se activa el error
        } else {
            fallo_cerca = 0;
        }
        mySerial.print("DIST:"); mySerial.println(distance); //Se envian distancia y angulo
        mySerial.print("ANG:"); mySerial.println("90");
        nextMillis2 = millis() + interval2;
    }

    // --------------------------------------------------
    //          6. Canal de comunicacion Serial
    // --------------------------------------------------
    if (mySerial.available()) { 

        // --------------------------------------------------
        //                  6'1. Lectura
        // --------------------------------------------------
        String input = mySerial.readStringUntil('\n');
        input.trim(); // Saca cosas como espacios, \n, ...
        Serial.println(input);

        int firstColon = input.indexOf(':');
        if (firstColon == -1) { // En caso de que no haya :
            Serial.println("Formato inválido. Use LABEL:VALOR");
            return;
        }

        String label = input.substring(0, firstColon); // divide el mensaje recibido por los :, como un split del python
        String valueStr = input.substring(firstColon + 1);
        valueStr.trim();

        // --------------------------------------------------
        //           6'2. Envio Python -> Satelite
        // --------------------------------------------------
        if (label == "1") { // Cambio de modo de transmision
            if (valueStr == "1") { // Se pausa la transmision
                Pausa2 = 1;
                Serial.println("Pausar");
            } 
            else if (valueStr == "0") { // Reanuda la transmision
                Pausa2 = 0;
                Serial.println("Reanudar");
            }
        }
        else if (label == "2") { // Cambio de calculador de media
            if (valueStr== "1") { // La media pasa a ser calculada en el satelite
                modo_Media_temperatura = 1;
                Serial.println("Satelite");
            } 
            else if (valueStr == "0") { // La media pasa a ser calculada en el satelite
                modo_Media_temperatura = 0;
                Serial.println("Tierra");
            }
            else {
                Serial.println("Valor MODO_TEMP desconocido");
            }
        }

        else if (label == "AUT") { // Cambio del modo automatico 
            int v = valueStr.toInt();
            aut = v;
            Serial.println(v ? "Modo auto" : "Modo manual");
        }
        else if (label == "ANGULO") { // Angulo insertado manualmente 
            Serial.print("Ángulo recibido: ");
            Serial.println(angulo);
        }
        else if (label =="3") { // Cambio del periodo de envio de temperatura y humedad
            interval1 = (valueStr.toInt()*1000); // Conversion a milisegundos
            Serial.print("Periodo temperatura recibido:");
            Serial.println(interval1);
        }
        else if (label =="4") { // Cambio del periodo de envio de distancia
            interval2 = (valueStr.toInt()*1000);
            Serial.print("Periodo distancia recibido:");
            Serial.println(interval2);
        }

        else {
            Serial.print("Comando no reconocido: ");
            Serial.println(input);
        }
    }
}
