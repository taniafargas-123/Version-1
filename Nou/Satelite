#include <SoftwareSerial.h>
#include <DHT.h>
#include <Servo.h>
#ifndef CHECKSUM_H
#define CHECKSUM_H
#include <stdint.h>
#include <stddef.h>
#endif
#include <string.h>
#include <stdio.h>

// ---------------- ENUM SERVOMODE ----------------

bool servoMode = 1;
// - DHT SENSOR --------------------
#define DHTPIN 2
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

// -------------------- SERVO -------------------------
Servo servoMotor;
float angulo = 90.0;
int sentido = 1;

// -------------------- TIMERS ------------------------
long nextMillis1;
long nextMillis2;
long nextMillis3;
long interval1 = 3000;
long interval2 = 5000;
long interval3 = 5000;
unsigned long nextImpresion;
unsigned long nextTimeoutHT;
int intervaloImpresion = 2000;

// -------------------- ORBIT CONSTANTS ----------------
const double G = 6.67430e-11;
const double M = 5.97219e24;
const double R_EARTH = 6371000;
const double ALTITUDE = 400000;
const double EARTH_ROTATION_RATE = 7.2921159e-5;
const unsigned long MILLIS_BETWEEN_UPDATES = 1000;
const double TIME_COMPRESSION = 90.0;

unsigned long nextUpdate;
double real_orbital_period;
double r;

double orbX = 0;
double orbY = 0;
double orbZ = 0;

// -------------------- DATA SENDING -------------------
int Pausa2 = 1;
int Pausa3 = 1;
int modo_Media_temperatura = 0;
float maximo_temp =99999;
int contador;
float temperaturas[100];
float suma = 0;
float m = 0;
int i = 0;

// -------------------- ULTRASONIC ---------------------
const int trigPin = 4;
const int echoPin = 5;
float duration;
float distance;

// -------------------- JOYSTICK ------------------------
int valX = 0;
int joyX = A0;
float velMotor = 0;

//nose
float t, h;

//Errores
bool esperandoTimeout = true;
bool fallo_TyH = 0;
bool fallo_tiempo = 0;
bool fallo_cerca = 0;
bool fallo_ultra = 0;

//Temperaturas_media
#define N_MEDIA 10
float bufferTemp[N_MEDIA];
int idxTemp = 0;
int numTemp = 0;
float sumaTemp = 0;
float mediaTemp = NAN;

// -------------------- SERIAL -------------------------
String input = "";
SoftwareSerial mySerial(10, 11);  // RX, TX


// -------------------- FUNCIONS ------------------------
float leerDistancia() {
  long duracion;
  float distancia = -1;

  for (int intento = 0; intento < 3; intento++) {
    digitalWrite(trigPin, LOW);
    delayMicroseconds(3);
    digitalWrite(trigPin, HIGH);
    delayMicroseconds(10);
    digitalWrite(trigPin, LOW);

    duracion = pulseIn(echoPin, HIGH, 30000);
    if (duracion > 0) {
      distancia = duracion * 0.0343 / 2.0;
      if (distancia > 2 && distancia < 400) {
        return distancia;
      }
    }
  }
  return -1;
}


// ======================================================
//                        SETUP
// ======================================================
void setup() {
  Serial.begin(9600);
  mySerial.begin(9600);

  nextMillis1 = millis() + interval1;
  nextMillis2 = millis() + interval2;
  nextImpresion = millis() + intervaloImpresion;
  contador =0;

  dht.begin();

  servoMotor.attach(6);
  servoMotor.write(angulo);

  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);

  r = R_EARTH + ALTITUDE;
  real_orbital_period = 2 * PI * sqrt(pow(r, 3) / (G * M));
  nextUpdate = MILLIS_BETWEEN_UPDATES;
}


// ======================================================
//                         LOOP
// ======================================================
void loop() {

  // --------------------------------------------------
  //  SENSOR + DATA SENDING
  // --------------------------------------------------
  if (Pausa2 == 0 && millis() >= nextMillis1) {
    h = dht.readHumidity();
    t = dht.readTemperature();

    if (isnan(h) || isnan(t)) {
      esperandoTimeout = true;
      mySerial.print("Ar:1");
    } else {
      esperandoTimeout = false;
      nextTimeoutHT = millis() + 5000;

      if (modo_Media_temperatura == 1) {
        sumaTemp -= bufferTemp[idxTemp];
        bufferTemp[idxTemp] = t;
        sumaTemp += t;

        idxTemp = (idxTemp + 1) % N_MEDIA;
        if (numTemp < N_MEDIA) numTemp++;{
            mediaTemp = sumaTemp / numTemp;
        }
        if (mediaTemp>maximo_temp){
            contador = contador + 1;
            if (contador>=3){
                mySerial.print("Aa:1");
            }
        else {
            contador=0;
        }
        }
      }

      mySerial.print("TEMP:");
      mySerial.println(t);
      mySerial.print("HUM:");
      mySerial.println(h);

      if (modo_Media_temperatura == 1) {
        mySerial.print("MED:");
        mySerial.println(mediaTemp);
      } else {
        mySerial.print("MED:NaN");
      }

      i++;
    }
    nextMillis1 = millis() + interval1;

  }



  // --------------------------------------------------
  //      3. Orbit simulation
  // --------------------------------------------------
  unsigned long currentTime = millis();
  if (currentTime > nextUpdate) {
    simulate_orbit(currentTime, 0, 0);
    nextUpdate = currentTime + MILLIS_BETWEEN_UPDATES;
  }

  // --------------------------------------------------
  //      4. CONTROL DEL SERVO
  // --------------------------------------------------

  if (servoMode == 0) { // MANUAL
    // Quiet fins que Python enviÃ¯ un angle
    angulo = constrain(angulo, 0, 180);
  }

  else if (servoMode == 1) { // RASTREO
    if (angulo >= 180) sentido = 0;
    if (angulo <= 0) sentido = 1;
    if (sentido == 0) angulo -= 0.3;
    else angulo += 0.3;
  }

  servoMotor.write(angulo);

  // --------------------------------------------------
  //      5. ULTRASONIC
  // --------------------------------------------------
  if (Pausa3 == 0 && millis() >= nextMillis2) {
    distance = leerDistancia();
    if (distance==-1){
        mySerial.println("Ab:1");
    }
    else{
        mySerial.println("Ab:0");
    }
    mySerial.print("ANG:");
    mySerial.println(angulo);
    mySerial.print("DIST:");
    mySerial.println(distance);
    if (distance<10){
        mySerial.println("Av:1");
    }
    else{
        mySerial.println("Av:0");
    }
    nextMillis2 = millis() + 1000;
  }

  // --------------------------------------------------
  //      6. ORBIT DATA
  // --------------------------------------------------
  if (Pausa2 == 0 && millis() >= nextMillis3) {
    mySerial.print("X:");
    mySerial.println(orbX);
    mySerial.print("Y:");
    mySerial.println(orbY);
    nextMillis3 = millis() + interval3;
  }

  // --------------------------------------------------
  //                SERIAL COMMANDS
  // --------------------------------------------------
  static String rxBuffer = "";
  while (mySerial.available()) {
    char c = mySerial.read();

    if (c == '\n') {
      rxBuffer.trim();

      int colon = rxBuffer.indexOf(':');
      if (colon == -1) {
        rxBuffer = "";
        break;
      }

      String label = rxBuffer.substring(0, colon);
      String valueStr = rxBuffer.substring(colon+1 );
      valueStr.trim();

      if (label == "AUT") {
        servoMode = valueStr.toInt();
      }

      else if (label == "5") {
        angulo = constrain(valueStr.toInt(), 0, 180);
        servoMode = 0;
      }
      else if (label == "6") {
        maximo_temp = valueStr.toInt();
      }

      else if (label == "1") {
        int m = valueStr.toInt();
        Serial.println(m);
        if (m==0)
          Pausa2 = 0;
        else if (m == 1)
          Pausa2 = 1;
        else if (m ==2 )
          Pausa3 = 0;
        else if (m ==3)
          Pausa3 = 1;
        else if (m==4)
          Pausa2=0;
          Pausa3=0;
      }

      else if (label == "2") {
        modo_Media_temperatura = valueStr.toInt();
      }

      else if (label == "3") {
        interval1 = valueStr.toInt() * 1000UL;
      }

      else if (label == "4") {
        interval2 = valueStr.toInt() * 1000UL;
      }

      rxBuffer = "";
    }

    else {
      rxBuffer += c;
      if (rxBuffer.length() > 50) rxBuffer = "";
    }
  }
  delay(10);
}


// ======================================================
//                  ORBIT SIMULATION FUNC
// ======================================================
void simulate_orbit(unsigned long millis, double inclination, int ecef) {
  double time = (millis / 1000) * TIME_COMPRESSION;
  double angle = 2 * PI * (time / real_orbital_period);

  orbX = r * cos(angle);
  orbY = r * sin(angle) * cos(inclination);
  orbZ = r * sin(angle) * sin(inclination);

  if (ecef) {
    double theta = EARTH_ROTATION_RATE * time;
    double x_ecef = orbX * cos(theta) - orbY * sin(theta);
    double y_ecef = orbX * sin(theta) + orbY * cos(theta);
    orbX = x_ecef;
    orbY = y_ecef;  }
}
