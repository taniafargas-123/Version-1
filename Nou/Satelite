#include <SoftwareSerial.h>
#include <DHT.h>
#include <Servo.h>
#ifndef CHECKSUM_H
#define CHECKSUM_H
#include <stdint.h>
#include <stddef.h>
#endif
#include <string.h>
#include <stdio.h>


// -------------------- DHT SENSOR --------------------
#define DHTPIN 2
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

// -------------------- SERVO -------------------------
Servo servoMotor; 
int angulo = 90;

// -------------------- TIMERS ------------------------
long nextMillis1;
long nextMillis2;
long nextMillis3;
long interval1 = 3000;
long interval2 = 5000;
long interval3 = 5000;
unsigned long nextImpresion;
unsigned long nextTimeoutHT;
int intervaloImpresion = 2000;

// -------------------- ORBIT CONSTANTS ----------------
const double G = 6.67430e-11;
const double M = 5.97219e24;
const double R_EARTH = 6371000;
const double ALTITUDE = 400000;
const double EARTH_ROTATION_RATE = 7.2921159e-5;
const unsigned long MILLIS_BETWEEN_UPDATES = 1000;
const double TIME_COMPRESSION = 90.0;

unsigned long nextUpdate;
double real_orbital_period;
double r;

double orbX = 0;
double orbY = 0;
double orbZ = 0;

// -------------------- DATA SENDING -------------------
int Pausa2 = 1;
int modo_Media_temperatura = 0;
float temperaturas[100];
float suma = 0;
float m = 0;
int i = 0;

// -------------------- ULTRASONIC ---------------------
const int trigPin = 4;
const int echoPin = 5;
float duration;
float distance;

// -------------------- JOYSTICK + SERVO ---------------
int aut = 1;
int valX = 0;
int joyX = A0;
float velMotor = 0;
int pinBoton = 3;
bool botonAnterior = HIGH;
int sentido = 0;
//nose
float t, h;

//Errores
bool esperandoTimeout = true;
bool fallo_TyH = 0;
bool fallo_tiempo = 0;
bool fallo_cerca = 0;
bool fallo_ultra1 = 0;

//Temperaturas_media
#define N_MEDIA 10
float bufferTemp[N_MEDIA];
int idxTemp = 0;
int numTemp = 0;
float sumaTemp = 0;
float mediaTemp = NAN;

// -------------------- SERIAL -------------------------
String input = "";
SoftwareSerial mySerial(10, 11); // RX, TX
// Before Setup Se crea una funcion para enviar todos los datos de una


float leerDistancia() {
    long duracion;
    float distancia = -1;
    for (int intento = 0; intento < 3; intento++) {
        digitalWrite(trigPin, LOW);
        delayMicroseconds(3);
        digitalWrite(trigPin, HIGH);
        delayMicroseconds(10);
        digitalWrite(trigPin, LOW);

        duracion = pulseIn(echoPin, HIGH, 30000);
        if (duracion > 0) {
            distancia = duracion * 0.0343 / 2.0;
            if (distancia > 2 && distancia < 400) {
                return distancia;
            }
        }
    }
    return -1;  // error claro y consistente
}
//Funciones checksum//

// ======================================================
//                        SETUP
// ======================================================
void setup() {
    Serial.begin(9600);
    mySerial.begin(9600);

    // timers
    nextMillis1 = millis() + interval1;
    nextMillis2 = millis() + interval2;
    nextImpresion = millis() + intervaloImpresion;

    // DHT
    dht.begin();

    // Servo
    servoMotor.attach(6);
    servoMotor.write(angulo);

    // Ultrasonic
    pinMode(trigPin, OUTPUT);
    pinMode(echoPin, INPUT);

    // Joystick button
    pinMode(pinBoton, INPUT_PULLUP);
    pinMode(3, OUTPUT);

    // Orbit simulation setup
    r = R_EARTH + ALTITUDE;
    real_orbital_period = 2 * PI * sqrt(pow(r, 3) / (G * M));
    nextUpdate = MILLIS_BETWEEN_UPDATES;
}

// ======================================================
//                         LOOP
// ======================================================
void loop() {

    // --------------------------------------------------
    //  SENSOR + DATA SENDING  every interval1
    // --------------------------------------------------
    if (Pausa2 == 0 && millis() >= nextMillis1) {
        h = dht.readHumidity();
        t = dht.readTemperature();

        if (isnan(h) || isnan(t)) { // Si H o T son NaN, empieza un temporizador para dar error
            esperandoTimeout = true;
            Serial.print("Error");
        } else {
            esperandoTimeout = false;
            fallo_TyH = 0; // En caso de que el fallo estuviera activo, se desactiva
            nextTimeoutHT = millis() + 5000;
            // -------- MEDIA MOVIL CORRECTA --------
            if (modo_Media_temperatura == 1) {
                sumaTemp -= bufferTemp[idxTemp];
                bufferTemp[idxTemp] = t;
                sumaTemp += t;

                idxTemp = (idxTemp + 1) % N_MEDIA;
                if (numTemp < N_MEDIA) numTemp++;

                mediaTemp = sumaTemp / numTemp;
            }


            // media móvil 10 valores
            if (modo_Media_temperatura == 1) {

                if (i > 9) {
                    suma = suma + temperaturas[i] - temperaturas[(i - 9)];
                    m = suma / 10.0;
                } 
                else {
                    suma += temperaturas[i];
                    m = suma / 10.0;
                }
            }
            mySerial.print("TEMP:"); mySerial.println(t);// Se envian T, H, y la media a la estacion de tierra
            mySerial.print("HUM:"); mySerial.println(h);

            if (modo_Media_temperatura == 1) {
                mySerial.print("MED:");
                mySerial.println(mediaTemp);
            } else {
                mySerial.print("MED:NaN");
            }

        i++;// Pasa al siguiente instante de temperatura
        }
        nextMillis1 = millis() + interval1;
    }
    
    //---------------------------------------------------
    //      2. Activador de alarma de T y H
    // --------------------------------------------------
    if (esperandoTimeout && (millis() >= nextTimeoutHT)) {
    fallo_TyH = 1; // Aquí sí se activa la alarma
    }// Aquí sí se activa la alarma

    // --------------------------------------------------
    //      3. Actualización de simulador de la orbita
    // --------------------------------------------------
    unsigned long currentTime = millis();
    if (currentTime > nextUpdate) {
        simulate_orbit(currentTime, 0, 0);
        nextUpdate = currentTime + MILLIS_BETWEEN_UPDATES;
    }

     // --------------------------------------------------
    //          4. Modo manual del servo
    // --------------------------------------------------
    if (!aut) {
        valX = analogRead(joyX);
        velMotor = abs(((valX - 500) / 500.00) * 4.00); // La velocidad depende de cuanto se tumba el joystick

        if (valX < 490 && angulo < 180) angulo += velMotor; // Evitar valores falsos del joystick drift
        else if (valX > 510 && angulo > 0) angulo -= velMotor;

        angulo = constrain(angulo, 0, 180); // Conversor de un numero de 0 a 1023 a uno de entre 0 y 180
    }

    // --------------------------------------------------
    //          4'1. Modo automatico del servo
    // --------------------------------------------------
    else {
        if (angulo >= 180) sentido = 0; 
        if (angulo <= 0) sentido = 1; // Si se pasa de 0  o de 180 vuelve al intervalo (0-180)

        if (sentido == 0) angulo -= 2;
        else angulo += 2; // El sentido determina hacia que lado giran, en este modo con velocidad constante
    }

    // ---- SENSOR ULTRASONICO ----
    if (Pausa2 == 0 && millis() >= nextMillis2){
        distance = leerDistancia(); //Detetca si hay un error y si no envia distancia
        if (distance == -1) {
            Serial.println("Lectura ultrasónica inválida");
            fallo_cerca = 0; // No marcar error de cercanía
        } else if (distance < 10) {
            fallo_cerca = 1;
        } else {
            fallo_cerca = 0;
        }
        mySerial.print("DIST:"); mySerial.println(distance);
        mySerial.print("ANG:"); mySerial.println(90);
        servoMotor.write(angulo);
        nextMillis2 = millis() + interval2;
    }

    if (Pausa2 == 0 && millis() >=nextMillis3){
        mySerial.print("X:"); mySerial.println(orbX);
        mySerial.print("Y:"); mySerial.println(orbY);
        nextMillis3 = millis() + interval3;
    }

// --------------------------------------------------
//                SERIAL COMMANDS (MEJORADO)
// --------------------------------------------------
static String rxBuffer = "";

while (mySerial.available()) {
    char c = mySerial.read();

    if (c == '\n') {
        rxBuffer.trim();
        Serial.println("RX: " + rxBuffer);

        int colon = rxBuffer.indexOf(':');
        if (colon == -1) {
            Serial.println("Formato inválido");
            rxBuffer = "";
            break;
        }

        String label = rxBuffer.substring(0, colon);
        String valueStr = rxBuffer.substring(colon + 1);
        valueStr.trim();

        // -------------------------------
        //        SWITCH BY LABEL
        // -------------------------------
        if (label == "1") {// Cambio de modo de transmision
            Pausa2 = valueStr.toInt();
        }
        else if (label == "2") {// Cambio de calculador de media
            modo_Media_temperatura = valueStr.toInt();
        }
        else if (label == "AUT") {
            aut = valueStr.toInt();
        }
        else if (label == "5") {// Angulo insertado manualmente 
            angulo = constrain(valueStr.toInt(), 0, 180);
        }
        else if (label == "3") {// Cambio del periodo de envio de temperatura y humedad
            interval1 = valueStr.toInt() * 1000UL;
        }
        else if (label == "4") { // Cambio del periodo de envio de distancia
            interval2 = valueStr.toInt() * 1000UL;
        }

        rxBuffer = "";  // limpiar buffer
    }
    else {
        rxBuffer += c;
        if (rxBuffer.length() > 50) rxBuffer = ""; // protección overflow
    }
}

}


// ======================================================
//                  ORBIT SIMULATION FUNC
// ======================================================
void simulate_orbit(unsigned long millis, double inclination, int ecef) {//simula la orbita

    double time = (millis / 1000) * TIME_COMPRESSION;
    double angle = 2 * PI * (time / real_orbital_period);

    orbX = r * cos(angle);
    orbY = r * sin(angle) * cos(inclination);
    orbZ = r * sin(angle) * sin(inclination);

    if (ecef) {
        double theta = EARTH_ROTATION_RATE * time;
        double x_ecef = orbX * cos(theta) - orbY * sin(theta);
        double y_ecef = orbX * sin(theta) + orbY * cos(theta);
        orbX = x_ecef;
        orbY = y_ecef;
    }
}
