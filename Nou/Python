import serial
import threading
import matplotlib
matplotlib.use("TkAgg")
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from mpl_toolkits.mplot3d import Axes3D  # Importació necessària per 3D
import time
import numpy as np
from tkinter import *
from tkinter import messagebox
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import re
import difflib
import sys
from collections import deque
import datetime
import tkinter.font as tkfont

# Ensure matplotlib can render CJK (Chinese) and avoid minus-sign issues
matplotlib.rcParams["font.sans-serif"] = ["Microsoft YaHei", "SimHei", "DejaVu Sans", "Arial Unicode MS"]
matplotlib.rcParams["font.family"] = "sans-serif"
matplotlib.rcParams["axes.unicode_minus"] = False

# --- CONFIGURACIÓN SERIAL ---
device = 'COM3'
mySerial = serial.Serial(device, 9600, timeout=1)

# --- GLOBALS ---
angles = np.linspace(0, np.pi, 181)     # radians, length 181 (0°..180°)
distancies = np.full(len(angles), np.nan)
running = False
ventana_abierta = True


# Time series
temperaturas = []
humedades = []
temperaturas_medias = []
eje_x = []
posicionx_vals = []
posiciony_vals = []
# Last-known position components (allow X and Y to arrive on different lines)
last_posx = None
last_posy = None
last_posz = None
# Flags to indicate which components have been updated since the last append
last_posx_updated = False
last_posy_updated = False
last_posz_updated = False

i = 0
j = 0

Grafica_izquierda = "Temperatura"   # "Temperatura" or "Humedad"
Grafica_derecha = "Distancia"       # "Distancia" or "Posicion"
Idioma = "Castellano" # Castellano Catala English o ...
Automatico = "Activado"  # Activado o Desactivado

# Variables media temp
modo_Media_temperatura=0
N = 10
buffer_temp = deque(maxlen=N)  # keep the last N temperature samples for median
Temperatura_media = None
maximo_temp = 99999

# Small helpers / constants
R_EARTH = 6371000  # meters
ALTITUDE = 400000.0  # Altitud (metres)
ORBIT_RADIUS = R_EARTH + ALTITUDE

# Debugging flag for trail handling
DEBUG_TRAIL = False  # Set to True to enable verbose debug prints

# Clean terminal output: show only a single tidy data line per iteration and
# print errors prefixed with [ERR]. Set to False to keep full verbose debug.
CLEAN_OUTPUT = True

def _fmt(v, precision=2):
    try:
        if v is None:
            return "-"
        if isinstance(v, (int,)):
            return str(v)
        return f"{float(v):.{precision}f}"
    except Exception:
        return str(v)

def print_clean_line(temperatura, humedad, dist, ang, last_posx, last_posy, last_posz, checksum_detected=None, checksum_ok=None):
    """Print a compact summary line of the most relevant variables."""
    t = _fmt(temperatura, 2)
    h = _fmt(humedad, 1)
    d = _fmt(dist, 2)
    a = _fmt(ang, 1)
    x = _fmt(last_posx, 2)
    y = _fmt(last_posy, 2)
    z = _fmt(last_posz, 2)
    if checksum_detected is None:
        chk = "-"
    else:
        if checksum_ok is None:
            chk = "DET"
        else:
            chk = "OK" if checksum_ok else "FAIL"
    print(f"[DATA] T={t}C H={h}% D={d} A={a} X={x} Y={y} Z={z} CHK={chk}")

# Linear ramp for temperature median display: scale median from 0 to full value over N samples
# (displayed_median = median(buffer_temp) * min(len(buffer_temp), N) / N)

# Paràmetres del Dibuix
MAX_POINTS = 500  # Nombre màxim de punts per dibuixar la trajectòria de l'òrbita
scale_factor = ORBIT_RADIUS / 1.5 # Escala visual: centre el rang de la gràfica
refresh_interval = 2 # Actualitza la gràfica cada 2 segons (ajusta si cal)
regex_position = re.compile(r"Position: \(X: ([\d\.-]+) m, Y: ([\d\.-]+) m, Z: ([\d\.-]+) m\)")

# Compute checksum candidates from parsed numeric fields or original line text
def compute_checksum_candidates(values, line_text=None):
    """Return a set of integer checksum candidates (0-255) computed from values.
    Strategies included: sum of rounded ints, xor of rounded ints, ASCII-sum of comma-joined reprs, ASCII-sum of original line (if available)."""
    candidates = set()
    try:
        # Rounded integer sum
        ints = [int(round(v)) & 0xFF for v in values]
        candidates.add(sum(ints) % 256)
        # XOR of ints
        xr = 0
        for iv in ints:
            xr ^= iv
        candidates.add(xr & 0xFF)
        # ASCII sum of comma-joined values
        s = ','.join(str(v) for v in values)
        try:
            candidates.add(sum(s.encode('ascii')) % 256)
        except Exception:
            pass
    except Exception:
        pass
    if line_text:
        try:
            candidates.add(sum(line_text.encode('ascii', errors='ignore')) % 256)
        except Exception:
            pass
    return candidates

def verify_checksum(expected, values, line_text=None):
    """Return True if expected matches any computed candidate."""
    try:
        cands = compute_checksum_candidates(values, line_text)
        if DEBUG_TRAIL:
            print(f"[CHK-VER] expected=0x{expected:02X} candidates={[hex(c) for c in cands]}")
        return (expected & 0xFF) in cands
    except Exception:
        return False

# 3D Orbit parameters
MAX_ORBIT_POINTS = 50  # Limita el rastro de la órbita en el gráfico 3D
orbit_trail_3d = deque(maxlen=MAX_ORBIT_POINTS)

# --- EVENTOS ---
TIPOS_EVENTO = ["comando", "alarma", "observacion"]

def registrar_evento(tipo, descripcion):
    """
    tipo: 'comando', 'alarma', 'observacion'
    descripcion: texto libre
    """
    if tipo not in TIPOS_EVENTO:
        print(f"[WARN] Tipo de evento desconocido: {tipo}")
        return

    ahora = datetime.datetime.now()
    dia = ahora.strftime("%d-%m-%Y")
    hora = ahora.strftime("%H:%M:%S")

    linea = f"{dia} {hora} {tipo} {descripcion}\n"

    try:
        with open("eventos.txt", "a") as f:
            f.write(linea)
        print("EVENTO REGISTRADO:", linea.strip())
    except Exception as e:
        print("Error al guardar evento:", e)


def cargar_eventos():
    eventos = []
    try:
        with open("eventos.txt", "r") as f:
            for linea in f:
                partes = linea.strip().split(" ", 3)
                if len(partes) < 4:
                    continue
                dia, hora, tipo, descripcion = partes
                eventos.append({
                    "dia": dia,
                    "hora": hora,
                    "tipo": tipo,
                    "descripcion": descripcion
                })
    except FileNotFoundError:
        pass
    return eventos


def filtrar_eventos(eventos, dia=None, tipo=None):
    filtrados = eventos
    if dia:
        filtrados = [e for e in filtrados if e["dia"] == dia]
    if tipo and tipo in TIPOS_EVENTO:
        filtrados = [e for e in filtrados if e["tipo"] == tipo]
    return filtrados

def abrir_ventana_eventos():
    eventos = cargar_eventos()

    vent = Toplevel(window)
    vent.title("Registro de eventos")
    vent.geometry("700x500")

    # --- Zona de filtros ---
    frame_filtros = Frame(vent)
    frame_filtros.pack(fill="x", padx=5, pady=5)

    Label(frame_filtros, text="Día (dd-mm-aaaa):").grid(row=0, column=0, padx=5, pady=2, sticky="w")
    entry_dia = Entry(frame_filtros, width=12)
    entry_dia.grid(row=0, column=1, padx=5, pady=2, sticky="w")

    Label(frame_filtros, text="Tipo:").grid(row=0, column=2, padx=5, pady=2, sticky="w")
    tipo_var = StringVar(frame_filtros)
    tipo_var.set("todos")
    opciones_tipo = ["todos"] + TIPOS_EVENTO
    menu_tipo = OptionMenu(frame_filtros, tipo_var, *opciones_tipo)
    menu_tipo.grid(row=0, column=3, padx=5, pady=2, sticky="w")

    # --- Zona de resultados ---
    text = Text(vent, wrap="word")
    text.pack(fill="both", expand=True, padx=5, pady=5)

    scrollbar = Scrollbar(text, command=text.yview)
    scrollbar.pack(side="right", fill="y")
    text.configure(yscrollcommand=scrollbar.set)

    def refrescar():
        # Recargar SIEMPRE desde archivo
        eventos = cargar_eventos()

        dia_filtro = entry_dia.get().strip()
        dia_filtro = dia_filtro if dia_filtro else None

        tipo_filtro = tipo_var.get()
        if tipo_filtro == "todos":
            tipo_filtro = None

        ev_filtrados = filtrar_eventos(eventos, dia=dia_filtro, tipo=tipo_filtro)

        text.delete("1.0", END)
        if not ev_filtrados:
            text.insert(END, "No hay eventos para este filtro.\n")
            return

        for e in ev_filtrados:
            linea = f"{e['dia']} {e['hora']} [{e['tipo']}] {e['descripcion']}\n"
            text.insert(END, linea)



    # Botón de aplicar filtro
    boton_filtrar = Button(frame_filtros, text="Aplicar filtro", command=refrescar)
    boton_filtrar.grid(row=0, column=4, padx=5, pady=2)

    # Cargar inicialmente todos
    refrescar()

# --- GUI functions ---
def Parar():
    global running
    if mySerial:
        try:
            mySerial.write(b'1:1')
            registrar_evento("comando", "Parar transmisión de datos parar temperatura")
        except Exception as e:
            print("Serial write error:", e)
    running = False
    print("⏸ Comunicación detenida")

def Reanudar():
    global running
    if mySerial:
        try:
            mySerial.write(b'1:0')
            registrar_evento("comando", "Reanudar transmisión de datos para temperatura")
        except Exception as e:
            print("Serial write error:", e)
    running = True
    print("▶ Comunicación reanudada")

def ReanudarDist():
    global running
    if mySerial:
        try:
            mySerial.write(b'1:2')
            registrar_evento("comando", "Reanudar transmisión de datos para distancia")
        except Exception as e:
            print("Serial write error:", e)
    
def PararDist():
    global running
    if mySerial:
        try:
            mySerial.write(b'1:3')
            registrar_evento("comando", "Parar transmisión de datos para distancia")
        except Exception as e:
            print("Serial write error:", e)
    
def automatic():
    global Automatico
    if Automatico == "Activado":
        Automatico = "Desactivado"
        if mySerial:
            try:
                mySerial.write(b'AUT:0')
                registrar_evento("comando", "Modo automático desactivado")
                AutomaticButton.config(text="Automatico")
            except Exception as e:
                print("Serial write error:", e)
    else:
        Automatico = "Activado"
        if mySerial:
            try:
                mySerial.write(b'AUT:1')
                registrar_evento("comando", "Modo automático activado")
                AutomaticButton.config(text="Manual")
            except Exception as e:
                print("Serial write error:", e)
    
def Enter_pressed(event=None):
    """Parse user text for 'periodo temperatura N' or 'periodo distancia N' (fuzzy)."""
    global periodo_temp, periodo_dist, angulo2, maximo_temp
    user_text = Texto.get().strip()
    
        # --- OBSERVACIONES DEL USUARIO ---
    if user_text.lower().startswith("comentari:"):
        comentario = user_text[len("comentari:"):].strip()
        if comentario:
            registrar_evento("observacion", comentario)
        Texto.delete(0, "end")
        return
    
    user_lower = user_text = Texto.get().lower().strip()
    numeros = re.findall(r"\d+", user_text)
    numero = int(numeros[0]) if numeros else None
    if numero is None:
        print("No se encontró número.")
        Texto.delete(0, "end")
        return

    comandos = ["periodo temperatura", "periodo distancia","Angulo","Maximo temperatura"]
    match = difflib.get_close_matches(user_lower, comandos, n=1, cutoff=0.4)
    if match:
        cmd = match[0]
        if cmd == "periodo temperatura":
            periodo_temp = numero
            print('3:'+str(numero))
            if mySerial:
                try:
                    mySerial.write(str('3:'+str(numero)).encode())
                    registrar_evento("comando", f"Periodo de temperatura cambiado a {periodo_temp}")
                except Exception as e:
                    print("Serial write error:", e)
        elif cmd == "periodo distancia":
            periodo_dist = numero
            print('4:'+str(numero))
            if mySerial:
                try:
                    mySerial.write(str('4:'+str(numero)).encode())
                    registrar_evento("comando", f"Periodo de distancia cambiado a {periodo_dist}")
                except Exception as e:
                    print("Serial write error:", e)
        elif cmd == "Angulo":
            angulo2 = numero
            print('5:'+str(numero))
            if mySerial:
                try:
                    mySerial.write(str('5:'+str(numero)).encode())
                    registrar_evento("comando", f"Angulo cambiado a {angulo2}")
                except Exception as e:
                    print("Serial write error:", e)
        elif cmd == "Maximo temperatura":
            maximo_temp = numero
            print('6:'+str(numero))
            if mySerial:
                try:
                    mySerial.write(str('6:'+str(numero)).encode())
                    registrar_evento("comando", f"Maximo temperatura cambiado a {maximo_temp}")
                except Exception as e:
                    print("Serial write error:", e)
    else:
        print("Comando no reconocido:", user_text)
    Texto.delete(0, "end")

def IniciarComunicacion():
    global running
    running = True
    if mySerial:
        try:
            mySerial.write(b'1:4')
        except Exception as e:
            print("Serial write error:", e)
    threadRecepcion = threading.Thread(target=IniciarComunicacion2, daemon=True)
    threadRecepcion.start()

def checksum(mensaje):
    sumaa = 0
    for i in mensaje:
        sumaa = sumaa+ord(i)
    sumaa = sumaa % 256
    return sumaa

def Comprueva(frase,respuesta):
    sumaa = 0
    for i in frase:
        sumaa = sumaa+ord(i)
    sumaa = sumaa%256
    if sumaa == respuesta:
        return 1
    else:
        return 0

def IniciarComunicacion2():
    print("Iniciado")
    global i, ventana_abierta, distancies, punt, linea, j, buffer_temp, Temperatura_media, last_posx, last_posy, last_posz, last_posx_updated, last_posy_updated, last_posz_updated
    Temperatura_media = np.nan
    angtemp = None
    disttemp = None
    while ventana_abierta:
        if running and mySerial.in_waiting > 0:
            temperatura = None
            humedad = None
            dist = None
            ang = None
            posicionx = None
            posiciony = None
            posicionz = None

            try:
                # Read raw bytes and decode robustly (avoid UnicodeDecodeError)
                line_bytes = mySerial.readline()
                if not line_bytes:
                    continue

                # Attempt to detect and verify checksum from raw bytes.
                # Supported formats we TRY to detect:
                #  - ASCII hex suffix separated by '*' : <data>*<HEXCS>
                #  - Binary trailing checksum byte: <data><CSUM_BYTE> where CSUM_BYTE == sum(data) % 256
                # We treat a binary trailing checksum as *present* only when the last byte is non-printable
                # (to avoid mis-detecting ordinary ASCII characters as a checksum).
                stripped = line_bytes.rstrip(b"\r\n")
                checksum_ok = None
                checksum_detected = False
                checksum_failed_raw = False
                fallback_expected = None
                data_bytes = stripped

                if DEBUG_TRAIL:
                    lb = stripped[-1] if len(stripped) > 0 else None
                    try:
                        lb_hex = hex(lb) if lb is not None else None
                    except Exception:
                        lb_hex = str(lb)
                    star_idx_preview = stripped.rfind(b"*")
                    print(f"[CHK] detection-hint len={len(stripped)}, star_idx_preview={star_idx_preview}, last_byte={lb_hex}, last_printable={(32 <= lb <= 126) if lb is not None else None}")

                # 1) Try ASCII hex suffix after '*'
                star_idx = stripped.rfind(b"*")
                if star_idx != -1 and star_idx < len(stripped)-1:
                    suffix = stripped[star_idx+1:]
                    try:
                        expected = int(suffix.decode('ascii'), 16)
                        csum = sum(stripped[:star_idx]) % 256
                        checksum_detected = True
                        fallback_expected = expected
                        if csum == expected:
                            checksum_ok = True
                            data_bytes = stripped[:star_idx]
                            if DEBUG_TRAIL:
                                print(f"[CHK] hex csum OK: computed=0x{csum:02X} suffix=0x{expected:02X}")
                        else:
                            checksum_ok = False
                            checksum_failed_raw = True
                            if DEBUG_TRAIL:
                                print(f"[CHK] hex csum FAIL: computed=0x{csum:02X} suffix=0x{expected:02X}")
                    except Exception:
                        # Not a valid hex suffix
                        checksum_detected = False

                # 2) If no ASCII hex checksum detected, consider binary trailing checksum if last byte is non-printable
                if not checksum_detected and len(stripped) >= 2:
                    last_byte = stripped[-1]
                    # Treat as binary checksum only when last_byte is non-printable control-like byte
                    if last_byte < 32 or last_byte > 126:
                        candidate = stripped[:-1]
                        checksum_detected = True
                        fallback_expected = last_byte
                        try:
                            csum_sum = sum(candidate) % 256
                            if csum_sum == last_byte:
                                checksum_ok = True
                                data_bytes = candidate
                                if DEBUG_TRAIL:
                                    print(f"[CHK] binary sum csum OK: computed=0x{csum_sum:02X} last_byte=0x{last_byte:02X}")
                            else:
                                # try XOR as a common alternative checksum
                                csum_xor = 0
                                for b in candidate:
                                    csum_xor ^= b
                                if csum_xor == last_byte:
                                    checksum_ok = True
                                    data_bytes = candidate
                                    if DEBUG_TRAIL:
                                        print(f"[CHK] binary XOR csum OK: computed=0x{csum_xor:02X} last_byte=0x{last_byte:02X}")
                                else:
                                    checksum_ok = False
                                    checksum_failed_raw = True
                                    if DEBUG_TRAIL:
                                        print(f"[CHK] binary csum FAIL: sum=0x{csum_sum:02X} xor=0x{csum_xor:02X} last_byte=0x{last_byte:02X}")
                        except Exception:
                            checksum_ok = False

                # If no checksum was detected, show a debug hint
                if not checksum_detected and DEBUG_TRAIL:
                    try:
                        print(f"[CHK] No checksum detected in line: {stripped.hex()}")
                    except Exception:
                        print("[CHK] No checksum detected in line (non-hex display)")

                # If a checksum was detected and failed, skip this line
                if checksum_detected and checksum_ok is False:
                    # If verbose debug is enabled, log raw drop reason; otherwise let fallback/parsed checks handle it.
                    if DEBUG_TRAIL:
                        try:
                            print(f"[CHK] Dropping line (checksum mismatch): {stripped.hex()}")
                        except Exception:
                            print("[CHK] Dropping line (checksum mismatch)")
                    # Allow fallback verification later; do not unconditionally continue here.
                    pass

                # Decode the data bytes to text for parsing (use replacement for undecodable bytes)
                try:
                    linea = data_bytes.decode('utf-8', errors='replace').strip()
                except Exception:
                    linea = data_bytes.decode('latin1', errors='replace').strip()

                # Minimal terminal output: when CLEAN_OUTPUT is enabled, suppress raw byte and raw-line noise
                if DEBUG_TRAIL:
                    try:
                        print(f"[RAW_BYTES] {line_bytes.hex()}")
                    except Exception:
                        print(f"[RAW_BYTES] {repr(line_bytes)}")
                    print(f"[RAW] {linea}")

                # Reset update flag for this iteration
                pos_updated = False

                # 1) Try Position(...) full-line format first
                mpos = regex_position.match(linea)
                if mpos:
                    try:
                        px = float(mpos.group(1))
                        py = float(mpos.group(2))
                        pz = float(mpos.group(3))
                        last_posx = px
                        last_posy = py
                        last_posz = pz
                        # mark that both X and Y were updated together
                        last_posx_updated = True
                        last_posy_updated = True
                        last_posz_updated = True
                        pos_updated = True
                        if DEBUG_TRAIL:
                            print(f"[PARSE] Position line -> X={px}, Y={py}, Z={pz}")
                    except Exception as e:
                        # Position parsing failed: report as an error so the terminal remains informative
                        print(f"[ERR] Position parse failed: {e}")
                else:
                    # 2) Try key:value form (e.g., "X: 123.4 m")
                    if ':' not in linea:
                        if DEBUG_TRAIL:
                            print("[PARSE] Line not key:value and not Position() - ignored")
                        continue

                    prefijo, valor = linea.split(':', 1)
                    try:
                        prefijo = str(prefijo).strip().upper()
                        # remove units/letters and allow comma decimals
                        valor_clean = re.sub(r'[^0-9\.,-]+', '', valor).replace(',', '.')
                        valor_num = float(valor_clean)
                    except Exception:
                        if DEBUG_TRAIL:
                            print(f"[PARSE] Valor no numérico para '{valor}' (raw: '{valor}')")
                        continue

                    if prefijo == 'TEMP':
                        temperatura = valor_num
                        j = j + 1
                    elif prefijo == 'HUM':
                        humedad = valor_num
                    elif prefijo == 'DIST':
                        dist = valor_num
                    elif prefijo == 'ANG':
                        ang = valor_num
                        print("1")
                        print(ang)
                    elif prefijo == 'X':
                        posicionx = valor_num
                        last_posx = valor_num
                        last_posx_updated = True
                        pos_updated = True
                        if DEBUG_TRAIL:
                            print(f"[PARSE] X update -> {valor_num}")
                    elif prefijo == 'Y':
                        posiciony = valor_num
                        last_posy = valor_num
                        last_posy_updated = True
                        pos_updated = True
                        if DEBUG_TRAIL:
                            print(f"[PARSE] Y update -> {valor_num}")
                    elif prefijo == 'MED':
                        if modo_Media_temperatura == 1:
                            Temperatura_media = valor_num
                            if DEBUG_TRAIL:
                                print(f"[PARSE] MED -> {valor_num}")
                    elif prefijo == 'Z':
                        posicionz = valor_num
                        last_posz = valor_num
                        last_posz_updated = True
                        pos_updated = True
                        if DEBUG_TRAIL:
                            print(f"[PARSE] Z update -> {valor_num}")
                    elif prefijo in ('CS', 'CHK', 'CHECK', 'CRC', 'SUM', 'CSUM'):
                        # Expected checksum value provided by Arduino. Try to parse it (support hex like 0xAB).
                        expected = None
                        raw_val = valor.strip()
                        try:
                            # int(..., 0) will handle 0xNN hex prefixes
                            expected = int(raw_val, 0)
                        except Exception:
                            # Try to find a hex token anywhere in the string (e.g., "*AB" or "AB")
                            mhex = re.search(r"([0-9A-Fa-f]{1,2})", raw_val)
                            if mhex:
                                try:
                                    expected = int(mhex.group(1), 16)
                                except Exception:
                                    expected = None
                            else:
                                # Fallback: try numeric extraction and cast
                                try:
                                    cleaned = re.sub(r'[^0-9\.,-]+', '', raw_val).replace(',', '.')
                                    expected = int(float(cleaned))
                                except Exception:
                                    expected = None

                        if expected is not None:
                            # Build a candidate values list from the numeric variables we know at this moment
                            values = []
                            for nm in ('temperatura', 'humedad', 'dist', 'ang', 'last_posx', 'last_posy', 'last_posz'):
                                try:
                                    v = locals().get(nm)
                                except Exception:
                                    v = None
                                if v is not None:
                                    values.append(v)

                            ok = verify_checksum(expected, values, line_text=linea)
                            if not ok:
                                # Always report failed explicit checksum fields as errors
                                print(f"[ERR] checksum verification FAILED -> expected=0x{expected:02X}, values={values}")
                                # Drop this line (invalid checksum)
                                continue
                            else:
                                if DEBUG_TRAIL:
                                    print(f"[CHK] checksum verification OK -> expected=0x{expected:02X}, values={values}")
                        else:
                            print(f"[ERR] could not parse expected checksum from '{valor}'")
                    else:
                        if DEBUG_TRAIL:
                            print("[PARSE] Prefijo no reconocido:", prefijo)
                
                    # If a raw-byte checksum was detected but raw validation failed, try to
                    # verify it using the parsed numeric variables (Arduino may compute
                    # checksum over numeric fields rather than raw bytes).
                    if checksum_detected and checksum_ok is False and checksum_failed_raw and fallback_expected is not None:
                        values = []
                        for nm in ('temperatura', 'humedad', 'dist', 'ang', 'last_posx', 'last_posy', 'last_posz'):
                            try:
                                v = locals().get(nm)
                            except Exception:
                                v = None
                            if v is not None:
                                values.append(v)

                        ok2 = verify_checksum(fallback_expected, values, line_text=linea)
                        if not ok2:
                            # Report fallback verification failure as an error
                            print(f"[ERR] Dropping line (checksum mismatch after parsed-values attempt): expected=0x{fallback_expected:02X}, values={values}")
                            continue
                        else:
                            if DEBUG_TRAIL:
                                print(f"[CHK] checksum OK via parsed-values fallback -> expected=0x{fallback_expected:02X}, values={values}")

                    # SOLO añadir cuando hay datos válidos
                if temperatura is not None:
                    eje_x.append(len(eje_x))
                    temperaturas.append(temperatura)

                if humedad is not None:
                    humedades.append(humedad)

                # Print a single clean summary line if requested
                try:
                    if CLEAN_OUTPUT:
                        # Only print when we have relevant data to show (avoid flooding with empty lines)
                        chk_det = checksum_detected if 'checksum_detected' in locals() else None
                        chk_ok = checksum_ok if 'checksum_ok' in locals() else None
                        if (temperatura is not None) or (humedad is not None) or (dist is not None) or pos_updated or (chk_det is True):
                            print_clean_line(temperatura, humedad, dist, ang, last_posx, last_posy, last_posz, checksum_detected=chk_det, checksum_ok=chk_ok)
                except Exception as e:
                    # Always show errors
                    print(f"[ERR] {e}")


                # Consolidar actualizaciones de posición: si hubo cambios de X/Y/Z en esta iteración
                if pos_updated:
                    # Sólo añadir cuando hemos recibido nuevas X y Y (evitar pasos ortogonals)
                    if (last_posx is not None) and (last_posy is not None) and last_posx_updated and last_posy_updated:
                        # Determinar z: preferir last_posz, o fallback al último z del rastro o 0.0
                        if last_posz is not None:
                            z_val = last_posz
                        else:
                            z_val = orbit_trail_3d[-1][2] if len(orbit_trail_3d) > 0 and orbit_trail_3d[-1][2] is not None else 0.0

                        posicionx_vals.append(last_posx)
                        posiciony_vals.append(last_posy)
                        orbit_trail_3d.append((last_posx, last_posy, z_val))

                        # reset update flags until new updates arrive
                        last_posx_updated = False
                        last_posy_updated = False
                        last_posz_updated = False

                        if DEBUG_TRAIL:
                            print(f"[TRAIL] Appended (paired) -> x={last_posx}, y={last_posy}, z={z_val}, trail_len={len(orbit_trail_3d)}")
                    else:
                        if DEBUG_TRAIL:
                            print(f"[TRAIL] Update received but waiting for both components -> last_x={last_posx} (u={last_posx_updated}), last_y={last_posy} (u={last_posy_updated})")


                # SOLO actualizar radar si ambos existen
                if ang is not None:
                    angtemp = ang
                if dist is not None:
                    disttemp = dist
                if angtemp is not None and disttemp is not None:
                    if 0 <= angtemp <= 180:

                        idx = int(round(angtemp))
                        distancies[idx] = disttemp

                        theta_rad = np.radians(idx)
                        punt = ([theta_rad], [disttemp])
                        
                        beam_polar.set_data([theta_rad, theta_rad], [0, disttemp])
                        disttemp = None
                        angtemp = None

                if temperatura is not None:
                    if modo_Media_temperatura == 0:
                        
                        # Keep last N values and compute the median from available samples so
                        # the median updates progressively from the first sample.
                        buffer_temp.append(temperatura)
                        try:
                            median_val = float(np.median(list(buffer_temp)))
                        except Exception:
                            median_val = float(buffer_temp[-1]) if len(buffer_temp) > 0 else np.nan

                        # Scale the displayed median linearly from 0 to full median over N samples
                        ramp_factor = min(len(buffer_temp), N) / float(N)
                        Temperatura_media = median_val * ramp_factor
                        if Temperatura_media>maximo_temp:
                            contador = contador + 1
                            if contador>=3:
                                if mySerial:
                                    try:
                                        mySerial.write(b'7:1')
                                        registrar_evento("alarma", f"Alarma de temperatura alta: {Temperatura_media:.2f}C")
                                    except Exception as e:
                                        print("Serial write error:", e)
                        else:
                            contador = 0
                        if DEBUG_TRAIL:
                            print(f"[MED] samples={len(buffer_temp)}, median={median_val}, ramp={ramp_factor:.2f}, displayed={Temperatura_media}")

                        # Guardar para la gráfica
                        temperaturas_medias.append(Temperatura_media)
                    else:
                        # modo_Media_temperatura == 1: use value received via 'MED' prefix if available
                        temperaturas_medias.append(Temperatura_media if Temperatura_media is not None else np.nan)


                actualizar_grafica(j)
                actualiza(posicionx, posiciony, posicionz)
                actualiza_grafica_3d() # Actualizar el gráfico 3D
            except Exception as e:
                print(f"[ERR] {e}")
        if not running and time.time()%3000 == 1:
            try:
                eje_x.append()
                temperaturas.append(np.nan)
                humedades.append(np.nan)    
                actualizar_grafica(j)
                actualiza(posicionx, posiciony, posicionz)
                actualiza_grafica_3d() # Actualizar el gráfico 3D
            except Exception as e:
                    print(f"[ERR] {e}")
# Toggle left graph
def cambiar_modo_izquierda():
    global Grafica_izquierda
    if Grafica_izquierda == "Temperatura":
        Grafica_izquierda = "Humedad"
        cambiarButtonizquierda.config(text="Mostrar Temperatura")
    else:
        Grafica_izquierda = "Temperatura"
        cambiarButtonizquierda.config(text="Mostrar Humedad")
    actualizar_grafica(i)

LANGUAGES = ["Castellano", "Catala", "English", "中文", "Français", "Deutsch"]

TRANSLATIONS = {
    "Castellano": {
        "title": "Monitor Serial",
        "real_time_graph": "Gráfica en tiempo real",
        "graph_3d": "Gráfica de Órbita 3D",
        "start": "Iniciar",
        "stop": "Parar",
        "resume": "Reanudar",
        "show_temperature": "Mostrar Temperatura",
        "show_humidity": "Mostrar Humedad",
        "show_position": "Mostrar Posicion",
        "show_distance": "Mostrar Distancia",
        "automatic_on": "Automático",
        "automatic_off": "Manual",
        "media_sat": "Media Sat",
        "media_earth": "Media Tierra",
        "view_events": "Ver eventos",
        "polar_title": "Radar de Ultrasonidos",
        "placeholder": "Escribe el periodo de temperatura y humedad o el periodo de la distancia",
        "temp_plot_title": "Gráfica de Temperatura",
        "hum_plot_title": "Gráfica de Humedad",
        "temp_ylabel": "Temperatura (°C)",
        "hum_ylabel": "Humedad (%)",
        "samples_xlabel": "Muestras",
        "dist_label": "Distancia",
        "beam_label": "BEAM",
        "current_point": "Punto actual",
        "orbit_label": "Órbita Satélite",
        "last_point_label": "Satélite Actual",
        "3d_title": "Órbita Satélite 3D (Matplotlib)",
        "x_label": "X (m)",
        "y_label": "Y (m)",
        "z_label": "Z (m)",
        "info_title":"Instrucciones",
        "info_text": "En la caja blanca de texto, puedes introducir:\n\n • El período en el que se envían los datos de temperatura y distancia.\n\n • El ángulo que quieres que gire el satélite.\n\n • Una temperatura máxima (la alarma azul sonará si se supera 3 veces). \n\n • Un comentario que aparece en el registro de eventos \n\n Según el dato que introduzcas, deberás escribir antes los respectivos comandos seguidos por un espacio:\n\n periodo temperatura, periodo distancia, angulo, maximo temperatura, comentario "

    },
    "Catala": {
        "title": "Monitor Serial",
        "real_time_graph": "Gràfica en temps real",
        "graph_3d": "Gràfica d'Òrbita 3D",
        "start": "Iniciar",
        "stop": "Atura",
        "resume": "Reprendre",
        "show_temperature": "Mostra Temperatura",
        "show_humidity": "Mostra Humitat",
        "show_position": "Mostra Posició",
        "show_distance": "Mostra Distància",
        "automatic_on": "Automàtic",
        "automatic_off": "Manual",
        "media_sat": "Mitjana Sat",
        "media_earth": "Mitjana Terra",
        "view_events": "Veure esdeveniments",
        "polar_title": "Radar d'Ultrasons",
        "placeholder": "Escriu el període de temperatura i humitat o el període de la distància",
        "temp_plot_title": "Gràfica de Temperatura",
        "hum_plot_title": "Gràfica de Humitat",
        "temp_ylabel": "Temperatura (°C)",
        "hum_ylabel": "Humitat (%)",
        "samples_xlabel": "Mostres",
        "dist_label": "Distància",
        "beam_label": "FEIX",
        "current_point": "Punt actual",
        "orbit_label": "Òrbita Satèl·lit",
        "last_point_label": "Satèl·lit Actual",
        "3d_title": "Òrbita Satèl·lit 3D (Matplotlib)",
        "x_label": "X (m)",
        "y_label": "Y (m)",
        "z_label": "Z (m)",
        "info_title":"Instruccions",
        "info_text": "A la capsa blanca de text, pots introduir:\n\n • El període en què s'envien les dades de temperatura i distància.\n\n • L'angle que vols que giri el satèl·lit.\n\n • Una temperatura màxima (l'alarma blava sonarà si se supera 3 cops). \n\n • Un comentari que surt al registre d'events \n\n Segons la dada que introdueixis, hauràs d'escriure abans els comandos respectius seguits per un espai: \n\n periodo temperatura, periodo distancia, angulo, maximo temperatura, comentario "
    },
    "English": {
        "title": "Serial Monitor",
        "real_time_graph": "Real-time plot",
        "graph_3d": "3D Orbit Plot",
        "start": "Start",
        "stop": "Stop",
        "resume": "Resume",
        "show_temperature": "Show Temperature",
        "show_humidity": "Show Humidity",
        "show_position": "Show Position",
        "show_distance": "Show Distance",
        "automatic_on": "Automatic",
        "automatic_off": "Manual",
        "media_sat": "Sat Avg",
        "media_earth": "Earth Avg",
        "view_events": "View events",
        "polar_title": "Ultrasounds radar",
        "placeholder": "Type the temperature/humidity period or the distance period",
        "temp_plot_title": "Temperature Plot",
        "hum_plot_title": "Humidity Plot",
        "temp_ylabel": "Temperature (°C)",
        "hum_ylabel": "Humidity (%)",
        "samples_xlabel": "Samples",
        "dist_label": "Distance",
        "beam_label": "BEAM",
        "current_point": "Current point",
        "orbit_label": "Satellite Orbit",
        "last_point_label": "Current Satellite",
        "3d_title": "Satellite Orbit 3D (Matplotlib)",
        "x_label": "X (m)",
        "y_label": "Y (m)",
        "z_label": "Z (m)",
        "info_title":"Instructions",
        "info_text": "In the white box above, you can enter:\n\n • The period in which the temperature and distance data are sent.\n\n • The angle you want the satellite to rotate.\n\n • A maximum temperature (the blue alarm will sound if it is exceeded 3 times). \n\n • A comment that appears in the event log \n\n Depending on the data you enter, you will have to write the respective commands first followed by a space:\n\n periodo temperatura, periodo distancia, angulo, maximo temperatura, comentario "
    },
    "中文": {
        "title": "串口监视器",
        "real_time_graph": "实时图表",
        "graph_3d": "3D 轨道图",
        "start": "启动",
        "stop": "停止",
        "resume": "继续",
        "show_temperature": "显示温度",
        "show_humidity": "显示湿度",
        "show_position": "显示位置",
        "show_distance": "显示距离",
        "automatic_on": "自动模式开启",
        "automatic_off": "自动模式关闭",
        "media_sat": "卫星均值",
        "media_earth": "地面均值",
        "view_events": "查看事件",
        "polar_title": "超声雷达",
        "placeholder": "输入温度/湿度周期或距离周期",
        "temp_plot_title": "温度图表",
        "hum_plot_title": "湿度图表",
        "temp_ylabel": "温度 (°C)",
        "hum_ylabel": "湿度 (%)",
        "samples_xlabel": "样本",
        "dist_label": "距离",
        "beam_label": "波束",
        "current_point": "当前点",
        "orbit_label": "卫星轨道",
        "last_point_label": "当前卫星",
        "3d_title": "卫星轨道 3D (Matplotlib)",
        "x_label": "X (m)",
        "y_label": "Y (m)",
        "z_label": "Z (m)",
        "info_title":"說明",
        "info_text": "在下面的白色框中，您可以輸入：\n\n • 發送溫度和距離資料的週期。 \n\n • 衛星旋轉角度。 \n\n • 最高溫度（如果超過最高溫度 3 次，將發出藍色警報）。 \n\n • 事件日誌中顯示的註解。 \n\n 根據您輸入的數據，您需要先輸入相應的命令，然後輸入一個空格：\n\n periodo temperatura, periodo distancia, angulo, maximo temperatura, comentario "
    },
    "Français": {
        "title": "Moniteur Série",
        "real_time_graph": "Graphique en temps réel",
        "graph_3d": "Graphique d'orbite 3D",
        "start": "Démarrer",
        "stop": "Arrêter",
        "resume": "Reprendre",
        "show_temperature": "Afficher Température",
        "show_humidity": "Afficher Humidité",
        "show_position": "Afficher Position",
        "show_distance": "Afficher Distance",
        "automatic_on": "Automatique",
        "automatic_off": "Manuel",
        "media_sat": "Moyenne Sat",
        "media_earth": "Moyenne Terre",
        "view_events": "Voir événements",
        "polar_title": "Radar à ultrasons",
        "placeholder": "Tapez la période température/humidité ou la période de distance",
        "temp_plot_title": "Graphique de Température",
        "hum_plot_title": "Graphique d'Humidité",
        "temp_ylabel": "Température (°C)",
        "hum_ylabel": "Humidité (%)",
        "samples_xlabel": "Échantillons",
        "dist_label": "Distance",
        "beam_label": "FAISCEAU",
        "current_point": "Point courant",
        "orbit_label": "Orbitesatellite",
        "last_point_label": "Satellite actuel",
        "3d_title": "Orbite Satellite 3D (Matplotlib)",
        "x_label": "X (m)",
        "y_label": "Y (m)",
        "z_label": "Z (m)",
        "info_title":"Instructions",
        "info_text":"Dans la zone blanche, vous pouvez saisir:\n\n • La période d'envoi des données de température et de distance.\n\n • L'angle de rotation souhaité pour le satellite.\n\n • Une température maximale (l'alarme bleue retentira si elle est dépassée 3 fois).\n\n • Un commentaire qui apparaîtra dans le journal des événements.\n\n Selon les données saisies, vous devrez d'abord écrire les commandes correspondantes, suivies d'un espace:\n\n periodo temperatura, periodo distancia, angulo, maximo temperatura, comentario "
    },
    "Deutsch": {
        "title": "Seriellmonitor",
        "real_time_graph": "Echtzeitdiagramm",
        "graph_3d": "3D Umlaufbahn Diagramm",
        "start": "Starten",
        "stop": "Stopp",
        "resume": "Fortsetzen",
        "show_temperature": "Temperatur anzeigen",
        "show_humidity": "Feuchtigkeit anzeigen",
        "show_position": "Position anzeigen",
        "show_distance": "Abstand anzeigen",
        "automatic_on": "Automatikmodus Ein",
        "automatic_off": "Automatikmodus Aus",
        "media_sat": "Sat Mittel",
        "media_earth": "Erd Mittel",
        "view_events": "Ereignisse anzeigen",
        "polar_title": "Ultraschall-Radar",
        "placeholder": "Geben Sie die Periode für Temperatur/Feuchte oder Abstand ein",
        "temp_plot_title": "Temperaturdiagramm",
        "hum_plot_title": "Feuchtigkeitsdiagramm",
        "temp_ylabel": "Temperatur (°C)",
        "hum_ylabel": "Feuchtigkeit (%)",
        "samples_xlabel": "Proben",
        "dist_label": "Abstand",
        "beam_label": "STRAHL",
        "current_point": "Aktueller Punkt",
        "orbit_label": "Satellitenbahn",
        "last_point_label": "Aktueller Satellit",
        "3d_title": "Satellitenbahn 3D (Matplotlib)",
        "x_label": "X (m)",
        "y_label": "Y (m)",
        "z_label": "Z (m)"
        "info_title":"Anleitung",
        "info_text":"Im weißen Feld unten können Sie Folgendes eingeben: \n\n • Den Zeitraum, in dem die Temperatur- und Entfernungsdaten gesendet werden.\n\n • Den gewünschten Drehwinkel des Satelliten.\n\n • Eine maximale Temperatur (der blaue Alarm ertönt, wenn diese dreimal überschritten wird). \n\n • Einen Kommentar, der im Ereignisprotokoll erscheint.\n\n Je nach den eingegebenen Daten müssen Sie zuerst die entsprechenden Befehle und anschließend ein Leerzeichen eingeben.\n\n periodo temperatura, periodo distancia, angulo, maximo temperatura, comentario "
    }
}

def update_texts():
    """Apply translations for current Idioma to all UI widgets (call after UI created)."""
    t = TRANSLATIONS.get(Idioma, TRANSLATIONS["Castellano"])
    try:
        # update window title too
        try:
            window.title(t.get("title", t["title"]))
        except Exception:
            pass

        tituloLabel.config(text=t["title"])
        frame_grafica.config(text=t["real_time_graph"])
        frame_grafica_3d.config(text=t["graph_3d"])
        IniciarButton.config(text=t["start"])
        PararButton.config(text=t["stop"])
        ReanudarButton.config(text=t["resume"])
        PararButtonPolar.config(text=t["stop"])
        ReanudarButtonPolar.config(text=t["resume"])
        VerEventosButton.config(text=t["view_events"])
        frame_info.config(text=t["info_title"])
        lbl_info.config(text=t["info_text"])

        # left toggle button text depends on current graph mode
        if Grafica_izquierda == "Temperatura":
            cambiarButtonizquierda.config(text=t["show_humidity"])
        else:
            cambiarButtonizquierda.config(text=t["show_temperature"])
        # right toggle button text depends on current graph mode
        if Grafica_derecha == "Distancia":
            cambiarButtonderecha.config(text=t["show_position"])
        else:
            cambiarButtonderecha.config(text=t["show_distance"])
        # automatic mode button 
        if Automatico == "Activado":
            AutomaticButton.config(text=t["automatic_off"])
        else:
            AutomaticButton.config(text=t["automatic_on"])
        # media mode button text
        if modo_Media_temperatura == 0:
            cambiarmediaButton.config(text=t["media_sat"])
        else:
            cambiarmediaButton.config(text=t["media_earth"])
        # placeholder handling: replace if empty OR if it currently equals any known placeholder
        cur = Texto.get()
        ph = t.get("placeholder", "")
        try:
            all_placeholders = {v.get("placeholder","") for v in TRANSLATIONS.values()}
        except Exception:
            all_placeholders = {ph}
        if cur.strip() == "" or cur in all_placeholders:
            Texto.delete(0, "end")
            Texto.insert(0, ph)
            Texto.config(fg="grey", font=("Microsoft YaHei", 12))
        # polar title
        polar_ax.set_title(t["polar_title"], va="bottom")
        # update left axis labels and title according to current mode
        if Grafica_izquierda == "Temperatura":
            ax.set_title(t["temp_plot_title"])
            ax.set_ylabel(t["temp_ylabel"])
        else:
            ax.set_title(t["hum_plot_title"])
            ax.set_ylabel(t["hum_ylabel"])
        ax.set_xlabel(t["samples_xlabel"])
        # update polar/cart legend labels
        try:
            punt_polar.set_label(t["current_point"])
            polar_ax.legend()
        except Exception:
            pass
        try:
            orbit_plot.set_label(t["orbit_label"])
            last_point_plot.set_label(t["last_point_label"])
            cart_ax.legend()
        except Exception:
            pass
        # 3D labels
        try:
            ax_3d.set_title(t["3d_title"])
            ax_3d.set_xlabel(t["x_label"])
            ax_3d.set_ylabel(t["y_label"])
            ax_3d.set_zlabel(t["z_label"])
        except Exception:
            pass
        # set IdiomaButton label to show next language in cycle
        idx = LANGUAGES.index(Idioma) if Idioma in LANGUAGES else 0
        next_lang = LANGUAGES[(idx + 1) % len(LANGUAGES)]
        IdiomaButton.config(text=next_lang)
        canvas_polar.draw_idle()
        canvas.draw_idle()
        canvas_3d.draw_idle()
    except Exception:
        # if called before widgets exist, ignore silently
        pass
    
def idiomafuncion():
    """Cycle Idioma and update UI texts."""
    global Idioma
    try:
        idx = LANGUAGES.index(Idioma)
        Idioma = LANGUAGES[(idx + 1) % len(LANGUAGES)]
    except ValueError:
        Idioma = LANGUAGES[0]
    registrar_evento("comando", f"Cambiar idioma a {Idioma}")
    update_texts()

# Toggle right graph (distance <-> position)
def cambiar_modo_derecha():
    global Grafica_derecha
    if Grafica_derecha == "Distancia":
        Grafica_derecha = "Posicion"
        cambiarButtonderecha.config(text="Mostrar Distancia")
    else:
        Grafica_derecha = "Distancia"
        cambiarButtonderecha.config(text="Mostrar Posicion")
    # show/hide axes accordingly
    polar_ax.set_visible(Grafica_derecha == "Distancia")
    cart_ax.set_visible(Grafica_derecha == "Posicion")
    canvas_polar.draw_idle()

def cambiar_modomedia():
    global modo_Media_temperatura
    if modo_Media_temperatura == 0:
        modo_Media_temperatura = 1
        cambiarmediaButton.config(text="Media Tierra")
        if mySerial:
            try:
                mySerial.write(b'2:1')
                registrar_evento("comando", "Cambiar modo media temperatura: calculada en satélite")
            except Exception as e:
                print("Serial write error:", e)
    else:
        modo_Media_temperatura = 0
        cambiarmediaButton.config(text="Media Sat")
        if mySerial:
            try:
                mySerial.write(b'2:0')
                registrar_evento("comando", "Cambiar modo media temperatura: calculada en tierra")
            except Exception as e:
                print("Serial write error:", e)

# --- Update left plot ---
def actualizar_grafica(x):
    """Update left time-series plot using translations for titles/labels."""
    t = TRANSLATIONS.get(Idioma, TRANSLATIONS["Castellano"])
    ax.clear()
    if Grafica_izquierda == "Temperatura":
        ax.set(xlim=(max(0, x-50), x+5), ylim=(0, 50))
        n = min(len(eje_x), len(temperaturas))
        ax.plot(eje_x[:n], temperaturas[:n], label=t["temp_ylabel"])
        n2 = min(len(eje_x), len(temperaturas_medias))
        ax.plot(eje_x[:n2], temperaturas_medias[:n2], label="Media temperaturas")
        ax.set_ylabel(t["temp_ylabel"])
        ax.set_title(t["temp_plot_title"])
    else:
        ax.set(xlim=(max(0, x-50), x+5), ylim=(0, 100))
        ax.plot(eje_x, humedades, label=t["hum_ylabel"])
        ax.set_ylabel(t["hum_ylabel"])
        ax.set_title(t["hum_plot_title"])
    ax.set_xlabel(t["samples_xlabel"])
    ax.legend()
    canvas.draw_idle()

# --- Update right plot (polar or cartesian) ---
def actualiza(posx, posy, posz):
    # Distance mode (polar)
    if Grafica_derecha == "Distancia":
        # update polar line and point
        angles_rad = np.radians(np.arange(0, 181))
        linea_polar.set_data(angles_rad, distancies)

        # update current point if punt defined
        try:
            if 'punt' in globals() and punt is not None:
                r = min(punt[1][0], polar_ax_rmax)
                punt_polar.set_data([punt[0][0]], [r])
            else:
                punt_polar.set_data([], [])
        except Exception:
            punt_polar.set_data([], [])
    else:
        # Position mode: update orbit plot
        if len(posicionx_vals) > 0:
            # update orbit line and last point
            orbit_plot.set_data(posicionx_vals, posiciony_vals)
            # scatter last point
            last_point_plot.set_offsets([[posicionx_vals[-1], posiciony_vals[-1]]])

            # remove only temporary Earth-slice patches (do not clear all patches)
            # use remove() to safely delete patches from the axis
            try:
                # iterate over a copy to avoid modifying the list while iterating
                for p in list(cart_ax.patches):
                    if getattr(p, "_temp_slice", False):
                        p.remove()
            except Exception:
                pass


            # expand limits if needed
            curx = posicionx_vals[-1]
            cury = posiciony_vals[-1]
            xlim = cart_ax.get_xlim()
            ylim = cart_ax.get_ylim()
            if abs(curx) > max(abs(xlim[0]), abs(xlim[1])) or abs(cury) > max(abs(ylim[0]), abs(ylim[1])):
                new_xlim = max(abs(xlim[0]), abs(xlim[1]), abs(curx)) * 1.1
                new_ylim = max(abs(ylim[0]), abs(ylim[1]), abs(cury)) * 1.1
                cart_ax.set_xlim(-new_xlim, new_xlim)
                cart_ax.set_ylim(-new_ylim, new_ylim)
    canvas_polar.draw_idle()

# --- Update 3D Orbit Plot (Matplotlib) ---
def actualiza_grafica_3d():
    """Actualiza y muestra el gráfico 3D de Matplotlib con el rastro de la órbita y la esfera de la Tierra."""
    t = TRANSLATIONS.get(Idioma, TRANSLATIONS["Castellano"])
    ax_3d.clear()
    
    # 0. Dibuixar l'Esfera de la Terra
    # Generar la malla de punts per a l'esfera de radi R_EARTH
    u_sphere = np.linspace(0, 2 * np.pi, 20)
    v_sphere = np.linspace(0, np.pi, 20)
    x_earth_sphere = R_EARTH * np.outer(np.cos(u_sphere), np.sin(v_sphere))
    y_earth_sphere = R_EARTH * np.outer(np.sin(u_sphere), np.sin(v_sphere))
    z_earth_sphere = R_EARTH * np.outer(np.ones(np.size(u_sphere)), np.cos(v_sphere))
    
    # Dibuixar l'esfera
    ax_3d.plot_surface(x_earth_sphere, y_earth_sphere, z_earth_sphere, 
                       color='blue', alpha=0.3, edgecolor='none', label='Earth')
    
    if not orbit_trail_3d:
        # Configuració inicial d'eixos si no hi ha dades
        lim = ORBIT_RADIUS * 1.2
        ax_3d.set_xlim([-lim, lim])
        ax_3d.set_ylim([-lim, lim])
        ax_3d.set_zlim([-lim, lim])
        ax_3d.set_xlabel(t["x_label"])
        ax_3d.set_ylabel(t["y_label"])
        ax_3d.set_zlabel(t["z_label"])
        ax_3d.set_title(t["3d_title"])
        canvas_3d.draw_idle()
        return
    
    # Extraer coordenadas del rastro
    x_orbit, y_orbit, z_orbit = zip(*orbit_trail_3d)
    
    # 1. Traçat de l'Òrbita (La Línia)
    ax_3d.plot(x_orbit, y_orbit, z_orbit, color='yellow', linewidth=3, label=t["orbit_label"])
    
    # 2. Posició Actual del Satèl·lit (El Punt)
    ax_3d.scatter([x_orbit[-1]], [y_orbit[-1]], [z_orbit[-1]], 
                  color='red', marker='o', s=50, label=t["last_point_label"], zorder=10)

    # Configuració del Layout
    ax_3d.set_title(t["3d_title"])
    
    # Establir límits dels eixos
    lim = ORBIT_RADIUS * 1.2
    ax_3d.set_xlim([-lim, lim])
    ax_3d.set_ylim([-lim, lim])
    ax_3d.set_zlim([-lim, lim])
    
    ax_3d.set_xlabel(t["x_label"])
    ax_3d.set_ylabel(t["y_label"])
    ax_3d.set_zlabel(t["z_label"])
    
    canvas_3d.draw_idle()

def cerrar_programa():
    global running, ventana_abierta
    if messagebox.askyesno("Salir", "¿Deseas cerrar el programa?"):
        ventana_abierta = False
        running = False
        try:
            if mySerial and mySerial.is_open:
                mySerial.close()
                print("Puerto serial cerrado correctamente.")
        except:
            pass
        window.destroy()
        sys.exit(0)


# --- TKINTER UI SETUP ---

# Create window first, then set a safe default font that supports CJK
window = Tk()
# Safely configure the Tk default font (avoids option_add string parsing issues)
try:
    default_font = tkfont.nametofont("TkDefaultFont")
    default_font.configure(family="Microsoft YaHei", size=11)
except Exception:
    try:
        # fallback to a common CJK font if available
        default_font = tkfont.nametofont("TkDefaultFont")
        default_font.configure(family="SimHei", size=11)
    except Exception:
        # leave defaults if no suitable font available
        pass

window.title("Monitor Serial - Temperatura y Humedad")
window.geometry("1200x900") # Aumentar altura per la nova gràfica 3D

# Grid layout
window.rowconfigure(1, weight=2) # Gráficas de arriba
window.rowconfigure(3, weight=3) # Gráfica 3D (nueva fila)
window.columnconfigure(1, weight=2)
window.columnconfigure(2, weight=2)
window.columnconfigure(3, weight=1) # Columna de botones derecha

tituloLabel = Label(window, text="Monitor Serial", font=("Times New Roman", 22, "italic"), bg='pink')
tituloLabel.grid(row=0, column=0, columnspan=4, padx=10, pady=10, sticky="nsew")

frame_botones = Frame(window, bg="lightpink", bd=2)
frame_botones.grid(row=1, column=0, padx=10, pady=10, sticky="nsew")

frame_botones_dos = Frame(window, bg="lightpink", bd=2)
frame_botones_dos.grid(row=1, column=3, padx=10, pady=10, sticky="nsew")

row2frame = Frame(window, bg="lightpink")
row2frame.grid(row=2, column=0, columnspan=4, pady=10, sticky="nsew")
row2frame.columnconfigure(1, weight=1)
# Input box with placeholder
input_user = StringVar()
def set_placeholder(event=None):
    try:
        t = TRANSLATIONS.get(Idioma, TRANSLATIONS["Castellano"])
        placeholder_text = t.get("placeholder", "Escribe el periodo de temperatura y humedad o el periodo de la distancia")
    except Exception:
        # TRANSLATIONS may not be defined yet; use a safe default
        placeholder_text = "Escribe el periodo de temperatura y humedad o el periodo de la distancia"
    if Texto.get() == "":
        Texto.insert(0, placeholder_text)
        Texto.config(fg="grey")

def clear_placeholder(event=None):
    try:
        t = TRANSLATIONS.get(Idioma, TRANSLATIONS["Castellano"])
        placeholder_text = t.get("placeholder", "Escribe el periodo de temperatura y humedad o el periodo de la distancia")
    except Exception:
        placeholder_text = "Escribe el periodo de temperatura y humedad o el periodo de la distancia"
    if Texto.get() == placeholder_text:
        Texto.delete(0, "end")
        Texto.config(fg="black")

# Use a font that displays Chinese; explicit font here ensures the Entry shows Chinese properly
Texto = Entry(row2frame, textvariable=input_user, width=60, font=("Microsoft YaHei", 12), fg="grey")
Texto.grid(row=0, column=1, padx=10, pady=5, sticky="nsew", ipady=8)
Texto.bind("<Return>", Enter_pressed)
Texto.bind("<FocusIn>", clear_placeholder)
Texto.bind("<FocusOut>", set_placeholder)
# Do not call set_placeholder here unconditionally; update_texts will set the correct localized placeholder once TRANSLATIONS is available

# Buttons
boton_style = {"font": ("Arial", 11), "width": 15, "height": 1}
IniciarButton = Button(frame_botones, text="Iniciar", bg='thistle', fg="black", command=IniciarComunicacion, **boton_style)
PararButton = Button(frame_botones, text="Parar", bg='lightblue', fg="black", command=Parar, **boton_style)
ReanudarButton = Button(frame_botones, text="Reanudar", bg='lightyellow', fg="black", command=Reanudar, **boton_style)
cambiarButtonizquierda = Button(frame_botones, text="Mostrar Humedad", bg='lightgreen', fg="black", command=cambiar_modo_izquierda, **boton_style)
cambiarmediaButton = Button(frame_botones, text="Media Sat", bg='lightyellow', fg="black", command=cambiar_modomedia, **boton_style)

IniciarButton.grid(row=0, column=0, padx=5, pady=5)
PararButton.grid(row=1, column=0, padx=5, pady=5)
ReanudarButton.grid(row=2, column=0, padx=5, pady=5)
cambiarButtonizquierda.grid(row=3, column=0, padx=5, pady=5)
cambiarmediaButton.grid(row=4, column=0, padx=5, pady=5)

PararButtonPolar = Button(frame_botones_dos, text ="Parar",bg ='lightblue',fg ="black",command =PararDist, **boton_style)
ReanudarButtonPolar = Button(frame_botones_dos, text="Reanudar", bg='lightyellow', fg="black", command=ReanudarDist, **boton_style)
cambiarButtonderecha = Button(frame_botones_dos, text="Mostrar Posicion", bg='lightgreen', fg="black", command=cambiar_modo_derecha, **boton_style)
# Replace IdiomaButton creation with a proper command and initial label showing the next language
next_idx = (LANGUAGES.index(Idioma) + 1) % len(LANGUAGES) if Idioma in LANGUAGES else 0
IdiomaButton = Button(frame_botones_dos, text=LANGUAGES[next_idx], bg='lightblue', fg='black', command=idiomafuncion, **boton_style)
AutomaticButton = Button(frame_botones_dos, text="Manual", bg='lightblue', fg='black', command=automatic, **boton_style)

VerEventosButton = Button(frame_botones, text="Ver eventos", bg='lavender', fg="black",
 command=abrir_ventana_eventos, **boton_style)
VerEventosButton.grid(row=5, column=0, padx=5, pady=5)


PararButtonPolar.grid(row=1, column=0, padx=5, pady=5)
ReanudarButtonPolar.grid(row=2, column=0, padx=5, pady=5)
cambiarButtonderecha.grid(row=3, column=0, padx=5, pady=5)
IdiomaButton.grid(row=4, column=0, padx=5, pady=5)
AutomaticButton.grid(row=5, column=0, padx=5, pady=5)

# --- Left graph (time series) ---
frame_grafica = LabelFrame(window, bg="white", bd=2, text="Gráfica en tiempo real", font=("Arial", 11))
frame_grafica.grid(row=1, column=1, padx=10, pady=10, sticky="nsew")
frame_grafica.rowconfigure(0, weight=1)
frame_grafica.columnconfigure(0, weight=1)

fig = matplotlib.figure.Figure(figsize=(6,4))
ax = fig.add_subplot(111)
canvas = FigureCanvasTkAgg(fig, master=frame_grafica)
canvas.get_tk_widget().grid(row=0, column=0, sticky="nsew")

# --- Right graph (polar or position) ---
frame_grafica_polar = LabelFrame(window, bg="white", bd=2, text="Gráfica en tiempo real", font=("Arial", 11))
frame_grafica_polar.grid(row=1, column=2, padx=10, pady=10, sticky="nsew")
frame_grafica_polar.rowconfigure(0, weight=1)
frame_grafica_polar.columnconfigure(0, weight=1)

fig_polar = matplotlib.figure.Figure(figsize=(6,4))
# create two axes: one polar and one cartesian; toggle visibility
polar_ax = fig_polar.add_subplot(1,1,1, polar=True)
cart_ax = fig_polar.add_subplot(1,1,1, polar=False, frame_on=True)  # will overlap; we will toggle visibility

# configure polar axis
polar_ax.set_theta_zero_location("E")
polar_ax.set_theta_direction(1)
polar_ax.set_thetalim(0, np.pi)
polar_ax_rmax = 50
polar_ax.set_rmax(polar_ax_rmax)
polar_ax.set_rticks([10,20,30,40,50])
polar_ax.set_rlabel_position(180)
polar_ax.set_title("Radar de Ultrasonidos", va='bottom')

# configure cartesian axis (for satellite position)
cart_ax.set_xlabel("X (meters)")
cart_ax.set_ylabel("Y (meters)")
cart_ax.set_title("Satellite Equatorial Orbit (View)")

# Set sensible initial limits for cartesian axis so Earth circle doesn't dominate
lim = R_EARTH * 1.2
cart_ax.set_xlim(-lim, lim)
cart_ax.set_ylim(-lim, lim)
cart_ax.set_aspect('equal', 'box')

# initial artists (polar mode)
linea_polar, = polar_ax.plot(np.radians(np.arange(0,181)), distancies, lw=2)
punt_polar, = polar_ax.plot([], [], "go", markersize=8, label="haz actual")
beam_polar, = polar_ax.plot([], [], lw=3, color='red', label="Distancia")
polar_ax.legend(loc='upper right')

# initial artists (cartesian mode)
orbit_plot, = cart_ax.plot([], [], 'bo-', markersize=2, label='Satellite Orbit')
last_point_plot = cart_ax.scatter([], [], color='red', s=30, label='Last Point')

# Add Earth surface as a patch on the correct axis (cart_ax) using patches (not plt.Circle)
earth_circle = mpatches.Circle((0, 0), R_EARTH, fill=False, edgecolor='orange', linewidth=1.5, zorder=0)
cart_ax.add_patch(earth_circle)

# Start with polar visible and cart hidden
polar_ax.set_visible(True)
cart_ax.set_visible(False)

canvas_polar = FigureCanvasTkAgg(fig_polar, master=frame_grafica_polar)
canvas_polar.get_tk_widget().grid(row=0, column=0, sticky="nsew")

# --- Bottom Graph (3D Orbit) ---
frame_grafica_3d = LabelFrame(window, bg="white", bd=2, text="Gráfica de Órbita 3D", font=("Arial", 11))
# Ubicación: Fila 3, columnas 0 a 3 (ocupa todo el ancho inferior)
frame_grafica_3d.grid(row=3, column=0, columnspan=4, padx=10, pady=10, sticky="nsew")
frame_grafica_3d.rowconfigure(0, weight=1)
frame_grafica_3d.columnconfigure(0, weight=1)

# Crear Figura y Eje 3D
fig_3d = matplotlib.figure.Figure(figsize=(12, 6))
# Importante: usar projection='3d'
ax_3d = fig_3d.add_subplot(111, projection='3d') 

canvas_3d = FigureCanvasTkAgg(fig_3d, master=frame_grafica_3d)
canvas_3d.get_tk_widget().grid(row=0, column=0, sticky="nsew")

frame_info = LabelFrame(window, bg="white", bd=2, text="Instrucciones:", font=("Arial", 11))
frame_info.grid(row=3, column=3, padx=10, pady=10, sticky="nsew")

text_informatiu = "En la caja blanca de debajo de todo, puedes introducir:\n\n • El período en el que se envían los datos de temperatura y distancia.\n\n • El ángulo que quieres que gire el satélite.\n\n • Una temperatura máxima (la alarma azul sonará si se supera 3 veces). \n\n • Un comentario que aparece en el registro de eventos \n\n Según el dato que introduzcas, deberás escribir antes los respectivos comandos seguidos por un espacio: \n periodo temperatura, periodo distancia, angulo, maximo temperatura, comentario "
lbl_info = Label(frame_info, text=text_informatiu, bg="light pink", font=("Arial", 12), justify="center", anchor="nw", wraplength=250)
lbl_info.pack(padx=15, pady=15, fill="both", expand=True)

window.columnconfigure(0, weight=1)
window.columnconfigure(1, weight=1)
window.columnconfigure(2, weight=1)
window.columnconfigure(3, weight=0) # La capseta de text no s'estira tant com gràfica
# Llamada inicial para establecer los límites del eje 3D
actualiza_grafica_3d()
update_texts()


# protocol
window.protocol("WM_DELETE_WINDOW", cerrar_programa)

# Start tkinter mainloop
window.mainloop()
