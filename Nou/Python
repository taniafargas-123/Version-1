import serial
import threading
import matplotlib
matplotlib.use("TkAgg")
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from mpl_toolkits.mplot3d import Axes3D  # Importació necessària per 3D
import time
import numpy as np
from tkinter import *
from tkinter import messagebox
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import re
import difflib
import sys
from collections import deque

# --- CONFIGURACIÓN SERIAL ---
device = 'COM5'
mySerial = serial.Serial(device, 9600, timeout=1)

# --- GLOBALS ---
angles = np.linspace(0, np.pi, 181)     # radians, length 181 (0°..180°)
distancies = np.full(len(angles), np.nan)
running = False
ventana_abierta = True

# Time series
temperaturas = []
humedades = []
temperaturas_medias = []
eje_x = []
posicionx_vals = []
posiciony_vals = []
i = 0
j= 0

Grafica_izquierda = "Temperatura"   # "Temperatura" or "Humedad"
Grafica_derecha = "Distancia"       # "Distancia" or "Posicion"

# Variables media temp
modo_Media_temperatura=0
buffer_temp = []
indice_temp = 0
contador_temp = 0
suma_temp = 0.0
Temperatura_media = None
N = 10




# Small helpers / constants
R_EARTH = 6371000  # meters
ALTITUDE = 400000.0  # Altitud (metres)
ORBIT_RADIUS = R_EARTH + ALTITUDE

# Paràmetres del Dibuix
MAX_POINTS = 500  # Nombre màxim de punts per dibuixar la trajectòria de l'òrbita
scale_factor = ORBIT_RADIUS / 1.5 # Escala visual: centre el rang de la gràfica
refresh_interval = 2 # Actualitza la gràfica cada 2 segons (ajusta si cal)
regex_position = re.compile(r"Position: \(X: ([\d\.-]+) m, Y: ([\d\.-]+) m, Z: ([\d\.-]+) m\)")

# 3D Orbit parameters
MAX_ORBIT_POINTS = 50  # Limita el rastro de la órbita en el gráfico 3D
orbit_trail_3d = deque(maxlen=MAX_ORBIT_POINTS)

# --- GUI functions ---
def Parar():
    global running
    if mySerial:
        try:
            mySerial.write(b'1:1')
        except Exception as e:
            print("Serial write error:", e)
    running = False
    print("⏸ Comunicación detenida")

def Reanudar():
    global running
    if mySerial:
        try:
            mySerial.write(b'1:0')
        except Exception as e:
            print("Serial write error:", e)
    running = True
    print("▶ Comunicación reanudada")

def nada():
    print('3:'+periodo_temp)

def Enter_pressed(event=None):
    """Parse user text for 'periodo temperatura N' or 'periodo distancia N' (fuzzy)."""
    global periodo_temp, periodo_dist
    user_text = Texto.get().lower().strip()

    numeros = re.findall(r"\d+", user_text)
    numero = int(numeros[0]) if numeros else None
    if numero is None:
        print("No se encontró número.")
        Texto.delete(0, "end")
        return

    comandos = ["periodo temperatura", "periodo distancia"]
    match = difflib.get_close_matches(user_text, comandos, n=1, cutoff=0.4)
    if match:
        cmd = match[0]
        if cmd == "periodo temperatura":
            periodo_temp = numero
            print('3:'+str(numero))
            if mySerial:
                try:
                    mySerial.write(str('3:'+str(numero)).encode())
                except Exception as e:
                    print("Serial write error:", e)
        elif cmd == "periodo distancia":
            periodo_dist = numero
            print('4:'+str(numero))
            if mySerial:
                try:
                    mySerial.write(str('4:'+str(numero)).encode())
                except Exception as e:
                    print("Serial write error:", e)
    else:
        print("Comando no reconocido:", user_text)
    Texto.delete(0, "end")

def IniciarComunicacion():
    global running
    running = True
    if mySerial:
        try:
            mySerial.write(b'1:0')
        except Exception as e:
            print("Serial write error:", e)
    threadRecepcion = threading.Thread(target=IniciarComunicacion2, daemon=True)
    threadRecepcion.start()

def checksum(mensaje):
    sumaa = 0
    for i in mensaje:
        sumaa = sumaa+ord(i)
    sumaa = sumaa % 256
    return sumaa

def Comprueva(frase,respuesta):
    sumaa = 0
    for i in frase:
        sumaa = sumaa+ord(i)
    sumaa = sumaa%256
    if sumaa == respuesta:
        return 1
    else:
        return 0

def IniciarComunicacion2():
    print("Iniciado")
    global i, ventana_abierta, distancies, punt, linea,j,buffer_temp, indice_temp, contador_temp, suma_temp, Temperatura_media
    suma = 0
    Temperatura_media = 0
    while ventana_abierta:
        if running and mySerial.in_waiting > 0:
            temperatura = None
            humedad = None
            dist = None
            ang = None
            posicionx = None
            posiciony = None
            posicionz = None
            ang =90
            try:
                linea = mySerial.readline().decode('utf-8').strip()
                print(linea)

                if ':' not in linea:
                    print("Línea inválida")
                    continue

                prefijo, valor = linea.split(':', 1)

                try:
                    prefijo = str(prefijo)
                    valor = float(valor)
                except ValueError:
                    print("Valor no numérico:", valor)
                    continue

                if prefijo == 'TEMP':
                    temperatura = valor
                    j =j+1
                elif prefijo == 'HUM':
                    humedad = valor
                elif prefijo == 'DIST':
                    dist = valor
                elif prefijo == 'ANG':
                    ang = valor
                elif prefijo == 'X':
                    posicionx = valor
                elif prefijo == 'Y':
                    posiciony = valor
                elif prefijo =='MED':
                    if modo_Media_temperatura == 1:
                        Temperatura_media = valor
                        print(Temperatura_media)
                elif prefijo == 'Z':
                    posicionz = valor
                else:
                    print("Prefijo no reconocido:", prefijo)
                
                # SOLO añadir cuando hay datos válidos
                if temperatura is not None:
                    eje_x.append(len(eje_x))
                    temperaturas.append(temperatura)
                    temperaturas_medias.append(Temperatura_media)

                if humedad is not None:
                    humedades.append(humedad)

                if posicionx is not None and posiciony is not None:
                    posicionx_vals.append(posicionx)
                    posiciony_vals.append(posiciony)
 
                
                if posicionx is not None and posiciony is not None and posicionz is not None:
                    orbit_trail_3d.append((posicionx, posiciony, posicionz))


                # SOLO actualizar radar si ambos existen
                if ang is not None and dist is not None:
                    if 0 <= ang <= 180:
                        idx = int(round(ang))
                        distancies[idx] = dist

                        theta_rad = np.radians(idx)
                        punt = ([theta_rad], [dist])

                        # beam
                        beam_polar.set_data([theta_rad, theta_rad], [0, dist])

                if modo_Media_temperatura == 0 and temperatura is not None:
                    # Fase inicial: menos de 10 valores
                    if len(buffer_temp) < N:
                        buffer_temp.append(temperatura)
                        suma_temp += temperatura
                    else:
                        # Bucle circular: sobrescribir el valor más antiguo
                        suma_temp -= buffer_temp[indice_temp]
                        buffer_temp[indice_temp] = temperatura
                        suma_temp += temperatura
                        indice_temp = (indice_temp + 1) % N

                    # Calcular media siempre con la cantidad actual de muestras
                    Temperatura_media = suma_temp / len(buffer_temp)

                    # Guardar para la gráfica
                    temperaturas_medias.append(Temperatura_media)


                actualizar_grafica(j)
                actualiza(posicionx, posiciony, posicionz)
                actualiza_grafica_3d() # Actualizar el gráfico 3D
            except Exception as e:
                print("Error:", e)
        if not running and time.time()%3000 == 1:
            try:
                eje_x.append()
                temperaturas.append(np.nan)
                humedades.append(np.nan)    
                actualizar_grafica(j)
                actualiza(posicionx, posiciony, posicionz)
                actualiza_grafica_3d() # Actualizar el gráfico 3D
            except Exception as e:
                print("Error:", e)

# Toggle left graph
def cambiar_modo_izquierda():
    global Grafica_izquierda
    if Grafica_izquierda == "Temperatura":
        Grafica_izquierda = "Humedad"
        cambiarButtonizquierda.config(text="Mostrar Temperatura")
    else:
        Grafica_izquierda = "Temperatura"
        cambiarButtonizquierda.config(text="Mostrar Humedad")
    actualizar_grafica(i)

# Toggle right graph (distance <-> position)
def cambiar_modo_derecha():
    global Grafica_derecha
    if Grafica_derecha == "Distancia":
        Grafica_derecha = "Posicion"
        cambiarButtonderecha.config(text="Mostrar Distancia")
    else:
        Grafica_derecha = "Distancia"
        cambiarButtonderecha.config(text="Mostrar Posicion")
    # show/hide axes accordingly
    polar_ax.set_visible(Grafica_derecha == "Distancia")
    cart_ax.set_visible(Grafica_derecha == "Posicion")
    canvas_polar.draw_idle()

def cambiar_modomedia():
    global modo_Media_temperatura
    if modo_Media_temperatura == 0:
        modo_Media_temperatura = 1
        cambiarmediaButton.config(text="Media Tierra")
        if mySerial:
            try:
                mySerial.write(b'2:1')
            except Exception as e:
                print("Serial write error:", e)
    else:
        modo_Media_temperatura = 0
        cambiarmediaButton.config(text="Media Sat")
        if mySerial:
            try:
                mySerial.write(b'2:0')
            except Exception as e:
                print("Serial write error:", e)

# --- Update left plot ---
def actualizar_grafica(x):
    ax.clear()
    if Grafica_izquierda == "Temperatura":
        ax.set(xlim=(max(0, x-50), x+5), ylim=(0, 50))
        n = min(len(eje_x), len(temperaturas))
        ax.plot(eje_x[:n], temperaturas[:n], label='Temperatura (°C)')
        n2 = min(len(eje_x), len(temperaturas_medias))
        ax.plot(eje_x[:n2], temperaturas_medias[:n2], label='Media temperaturas')
        ax.set_ylabel('Temperatura (°C)')
        ax.set_title('Gráfica de Temperatura')
    else:
        ax.set(xlim=(max(0, x-50), x+5), ylim=(0, 100))
        ax.plot(eje_x, humedades, label='Humedad (%)')
        ax.set_ylabel('Humedad (%)')
        ax.set_title('Gráfica de Humedad')
    ax.set_xlabel('Muestras')
    ax.legend()
    canvas.draw_idle()

# --- Update right plot (polar or cartesian) ---
def actualiza(posx, posy, posz):
    # Distance mode (polar)
    if Grafica_derecha == "Distancia":
        # update polar line and point
        angles_rad = np.radians(np.arange(0, 181))
        linea_polar.set_data(angles_rad, distancies)

        # update current point if punt defined
        try:
            if 'punt' in globals() and punt is not None:
                r = min(punt[1][0], polar_ax_rmax)
                punt_polar.set_data([punt[0][0]], [r])
            else:
                punt_polar.set_data([], [])
        except Exception:
            punt_polar.set_data([], [])
    else:
        # Position mode: update orbit plot
        if len(posicionx_vals) > 0:
            # update orbit line and last point
            orbit_plot.set_data(posicionx_vals, posiciony_vals)
            # scatter last point
            last_point_plot.set_offsets([[posicionx_vals[-1], posiciony_vals[-1]]])

            # remove only temporary Earth-slice patches (do not clear all patches)
            # use remove() to safely delete patches from the axis
            try:
                # iterate over a copy to avoid modifying the list while iterating
                for p in list(cart_ax.patches):
                    if getattr(p, "_temp_slice", False):
                        p.remove()
            except Exception:
                pass


            # expand limits if needed
            curx = posicionx_vals[-1]
            cury = posiciony_vals[-1]
            xlim = cart_ax.get_xlim()
            ylim = cart_ax.get_ylim()
            if abs(curx) > max(abs(xlim[0]), abs(xlim[1])) or abs(cury) > max(abs(ylim[0]), abs(ylim[1])):
                new_xlim = max(abs(xlim[0]), abs(xlim[1]), abs(curx)) * 1.1
                new_ylim = max(abs(ylim[0]), abs(ylim[1]), abs(cury)) * 1.1
                cart_ax.set_xlim(-new_xlim, new_xlim)
                cart_ax.set_ylim(-new_ylim, new_ylim)
    canvas_polar.draw_idle()

# --- Update 3D Orbit Plot (Matplotlib) ---
def actualiza_grafica_3d():
    """Actualiza y muestra el gráfico 3D de Matplotlib con el rastro de la órbita y la esfera de la Tierra."""
    ax_3d.clear()
    
    # 0. Dibuixar l'Esfera de la Terra
    # Generar la malla de punts per a l'esfera de radi R_EARTH
    u_sphere = np.linspace(0, 2 * np.pi, 20)
    v_sphere = np.linspace(0, np.pi, 20)
    x_earth_sphere = R_EARTH * np.outer(np.cos(u_sphere), np.sin(v_sphere))
    y_earth_sphere = R_EARTH * np.outer(np.sin(u_sphere), np.sin(v_sphere))
    z_earth_sphere = R_EARTH * np.outer(np.ones(np.size(u_sphere)), np.cos(v_sphere))
    
    # Dibuixar l'esfera
    ax_3d.plot_surface(x_earth_sphere, y_earth_sphere, z_earth_sphere, 
                       color='blue', alpha=0.3, edgecolor='none', label='Terra')
    
    if not orbit_trail_3d:
        # Configuració inicial d'eixos si no hi ha dades
        lim = ORBIT_RADIUS * 1.2
        ax_3d.set_xlim([-lim, lim])
        ax_3d.set_ylim([-lim, lim])
        ax_3d.set_zlim([-lim, lim])
        ax_3d.set_xlabel('X (m)')
        ax_3d.set_ylabel('Y (m)')
        ax_3d.set_zlabel('Z (m)')
        ax_3d.set_title('Órbita Satélite 3D (Matplotlib)')
        canvas_3d.draw_idle()
        return
    
    # Extraer coordenadas del rastro
    x_orbit, y_orbit, z_orbit = zip(*orbit_trail_3d)
    
    # 1. Traçat de l'Òrbita (La Línia)
    ax_3d.plot(x_orbit, y_orbit, z_orbit, color='yellow', linewidth=3, label='Órbita Satélite')
    
    # 2. Posició Actual del Satèl·lit (El Punt)
    ax_3d.scatter([x_orbit[-1]], [y_orbit[-1]], [z_orbit[-1]], 
                  color='red', marker='o', s=50, label='Satélite Actual', zorder=10) # zorder per assegurar-se que està al davant

    # Configuració del Layout
    ax_3d.set_title('Órbita Satélite 3D (Matplotlib)')
    
    # Establir límits dels eixos
    lim = ORBIT_RADIUS * 1.2
    ax_3d.set_xlim([-lim, lim])
    ax_3d.set_ylim([-lim, lim])
    ax_3d.set_zlim([-lim, lim])
    
    ax_3d.set_xlabel('X (m)')
    ax_3d.set_ylabel('Y (m)')
    ax_3d.set_zlabel('Z (m)')
    
    # Leyenda y redibujo
    # ax_3d.legend(loc='lower left')
    canvas_3d.draw_idle()


def cerrar_programa():
    global running, ventana_abierta
    if messagebox.askyesno("Salir", "¿Deseas cerrar el programa?"):
        ventana_abierta = False
        running = False
        try:
            if mySerial and mySerial.is_open:
                mySerial.close()
                print("Puerto serial cerrado correctamente.")
        except:
            pass
        window.destroy()
        sys.exit(0)



# --- TKINTER UI SETUP ---
window = Tk()
window.title("Monitor Serial - Temperatura y Humedad")
window.geometry("1200x900") # Aumentar altura per la nova gràfica 3D
window.configure(bg="lightpink")

# Grid layout
window.rowconfigure(1, weight=2) # Gráficas de arriba
window.rowconfigure(3, weight=3) # Gráfica 3D (nueva fila)
window.columnconfigure(1, weight=2)
window.columnconfigure(2, weight=2)
window.columnconfigure(3, weight=1) # Columna de botones derecha

tituloLabel = Label(window, text="Monitor Serial", font=("Times New Roman", 22, "italic"), bg='pink')
tituloLabel.grid(row=0, column=0, columnspan=4, padx=10, pady=10, sticky="nsew")

frame_botones = Frame(window, bg="lightpink", bd=2)
frame_botones.grid(row=1, column=0, padx=10, pady=10, sticky="nsew")

frame_botones_dos = Frame(window, bg="lightpink", bd=2)
frame_botones_dos.grid(row=1, column=3, padx=10, pady=10, sticky="nsew")

row2frame = Frame(window, bg="lightpink")
row2frame.grid(row=2, column=0, columnspan=4, pady=10, sticky="nsew")
row2frame.columnconfigure(1, weight=1)

# Input box with placeholder
input_user = StringVar()
def set_placeholder(event=None):
    if Texto.get() == "":
        Texto.insert(0, "Escribe el periodo de temperatura y humedad o el periodo de la distancia")
        Texto.config(fg="grey")
def clear_placeholder(event=None):
    if Texto.get() == "Escribe el periodo de temperatura y humedad o el periodo de la distancia":
        Texto.delete(0, "end")
        Texto.config(fg="black")

Texto = Entry(row2frame, textvariable=input_user, width=60, font=("Arial", 12), fg="grey")
Texto.grid(row=0, column=1, padx=10, pady=5, sticky="nsew", ipady=8)
Texto.bind("<Return>", Enter_pressed)
Texto.bind("<FocusIn>", clear_placeholder)
Texto.bind("<FocusOut>", set_placeholder)
set_placeholder()

# Buttons
boton_style = {"font": ("Arial", 11), "width": 15, "height": 2}
IniciarButton = Button(frame_botones, text="Iniciar", bg='thistle', fg="black", command=IniciarComunicacion, **boton_style)
PararButton = Button(frame_botones, text="Parar", bg='lightblue', fg="black", command=Parar, **boton_style)
ReanudarButton = Button(frame_botones, text="Reanudar", bg='lightyellow', fg="black", command=Reanudar, **boton_style)
cambiarButtonizquierda = Button(frame_botones, text="Mostrar Humedad", bg='lightgreen', fg="black", command=cambiar_modo_izquierda, **boton_style)
cambiarmediaButton = Button(frame_botones, text="Media Sat", bg='lightyellow', fg="black", command=cambiar_modomedia, **boton_style)

IniciarButton.grid(row=0, column=0, padx=5, pady=5)
PararButton.grid(row=1, column=0, padx=5, pady=5)
ReanudarButton.grid(row=2, column=0, padx=5, pady=5)
cambiarButtonizquierda.grid(row=3, column=0, padx=5, pady=5)
cambiarmediaButton.grid(row=4, column=0, padx=5, pady=5)

PararButtonPolar = Button(frame_botones_dos, text ="Parar",bg ='lightblue',fg ="black",command =nada, **boton_style)
ReanudarButtonPolar = Button(frame_botones_dos, text="Reanudar", bg='lightyellow', fg="black", command=nada, **boton_style)
cambiarButtonderecha = Button(frame_botones_dos, text="Mostrar Posicion", bg='lightgreen', fg="black", command=cambiar_modo_derecha, **boton_style)

PararButtonPolar.grid(row=1, column=0, padx=5, pady=5)
ReanudarButtonPolar.grid(row=2, column=0, padx=5, pady=5)
cambiarButtonderecha.grid(row=3, column=0, padx=5, pady=5)

# --- Left graph (time series) ---
frame_grafica = LabelFrame(window, bg="white", bd=2, text="Gráfica en tiempo real", font=("Arial", 11))
frame_grafica.grid(row=1, column=1, padx=10, pady=10, sticky="nsew")
frame_grafica.rowconfigure(0, weight=1)
frame_grafica.columnconfigure(0, weight=1)

fig = matplotlib.figure.Figure(figsize=(6,4))
ax = fig.add_subplot(111)
canvas = FigureCanvasTkAgg(fig, master=frame_grafica)
canvas.get_tk_widget().grid(row=0, column=0, sticky="nsew")

# --- Right graph (polar or position) ---
frame_grafica_polar = LabelFrame(window, bg="white", bd=2, text="Gráfica en tiempo real", font=("Arial", 11))
frame_grafica_polar.grid(row=1, column=2, padx=10, pady=10, sticky="nsew")
frame_grafica_polar.rowconfigure(0, weight=1)
frame_grafica_polar.columnconfigure(0, weight=1)

fig_polar = matplotlib.figure.Figure(figsize=(6,4))
# create two axes: one polar and one cartesian; toggle visibility
polar_ax = fig_polar.add_subplot(1,1,1, polar=True)
cart_ax = fig_polar.add_subplot(1,1,1, polar=False, frame_on=True)  # will overlap; we will toggle visibility

# configure polar axis
polar_ax.set_theta_zero_location("E")
polar_ax.set_theta_direction(1)
polar_ax.set_thetalim(0, np.pi)
polar_ax_rmax = 50
polar_ax.set_rmax(polar_ax_rmax)
polar_ax.set_rticks([10,20,30,40,50])
polar_ax.set_rlabel_position(180)
polar_ax.set_title("Radar de Ultrasonidos", va='bottom')

# configure cartesian axis (for satellite position)
cart_ax.set_xlabel("X (meters)")
cart_ax.set_ylabel("Y (meters)")
cart_ax.set_title("Satellite Equatorial Orbit (View)")

# Set sensible initial limits for cartesian axis so Earth circle doesn't dominate
lim = R_EARTH * 1.2
cart_ax.set_xlim(-lim, lim)
cart_ax.set_ylim(-lim, lim)
cart_ax.set_aspect('equal', 'box')

# initial artists (polar mode)
linea_polar, = polar_ax.plot(np.radians(np.arange(0,181)), distancies, lw=2, label="Distancia")
punt_polar, = polar_ax.plot([], [], "go", markersize=8, label="haz actual")
beam_polar, = polar_ax.plot([], [], lw=3, label="BEAM")
polar_ax.legend(loc='upper right')

# initial artists (cartesian mode)
orbit_plot, = cart_ax.plot([], [], 'bo-', markersize=2, label='Satellite Orbit')
last_point_plot = cart_ax.scatter([], [], color='red', s=30, label='Last Point')

# Add Earth surface as a patch on the correct axis (cart_ax) using patches (not plt.Circle)
earth_circle = mpatches.Circle((0, 0), R_EARTH, fill=False, edgecolor='orange', linewidth=1.5, zorder=0)
cart_ax.add_patch(earth_circle)

# Start with polar visible and cart hidden
polar_ax.set_visible(True)
cart_ax.set_visible(False)

canvas_polar = FigureCanvasTkAgg(fig_polar, master=frame_grafica_polar)
canvas_polar.get_tk_widget().grid(row=0, column=0, sticky="nsew")

# --- Bottom Graph (3D Orbit) ---
frame_grafica_3d = LabelFrame(window, bg="white", bd=2, text="Gráfica de Órbita 3D", font=("Arial", 11))
# Ubicación: Fila 3, columnas 0 a 3 (ocupa todo el ancho inferior)
frame_grafica_3d.grid(row=3, column=0, columnspan=4, padx=10, pady=10, sticky="nsew")
frame_grafica_3d.rowconfigure(0, weight=1)
frame_grafica_3d.columnconfigure(0, weight=1)

# Crear Figura y Eje 3D
fig_3d = matplotlib.figure.Figure(figsize=(12, 6))
# Importante: usar projection='3d'
ax_3d = fig_3d.add_subplot(111, projection='3d') 

canvas_3d = FigureCanvasTkAgg(fig_3d, master=frame_grafica_3d)
canvas_3d.get_tk_widget().grid(row=0, column=0, sticky="nsew")

# Llamada inicial para establecer los límites del eje 3D
actualiza_grafica_3d()


# protocol
window.protocol("WM_DELETE_WINDOW", cerrar_programa)

# Start tkinter mainloop
window.mainloop()
