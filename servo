#include <SoftwareSerial.h>
#include <DHT.h>
#include <Servo.h>
#ifndef CHECKSUM_H
#define CHECKSUM_H
#include <stdint.h>
#include <stddef.h>
#endif
#include <string.h>
#include <stdio.h>


// -------------------- DHT SENSOR --------------------
#define DHTPIN 2
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

// -------------------- SERVO -------------------------
Servo servoMotor;
int angulo = 90;
int aut = 1; // 1: Automatic (Scanning), 0: Manual (Fixed angle via Serial command '5')
int sentido = 0; // 0: Decrement, 1: Increment

// -------------------- TIMERS ------------------------
long nextMillis1;
long nextMillis2;
long nextMillis3;
long interval1 = 3000;
long interval2 = 5000;
long interval3 = 5000;
unsigned long nextImpresion;
unsigned long nextTimeoutHT;
int intervaloImpresion = 2000;

// Servo timer for smooth scanning
unsigned long lastServoMove = 0;
const int servoSpeed = 15; // Time in ms between each 1-degree step for smooth movement

// -------------------- ORBIT CONSTANTS ----------------
const double G = 6.67430e-11;
const double M = 5.97219e24;
const double R_EARTH = 6371000;
const double ALTITUDE = 400000;
const double EARTH_ROTATION_RATE = 7.2921159e-5;
const unsigned long MILLIS_BETWEEN_UPDATES = 1000;
const double TIME_COMPRESSION = 90.0;

unsigned long nextUpdate;
double real_orbital_period;
double r;

double orbX = 0;
double orbY = 0;
double orbZ = 0;

// -------------------- DATA SENDING -------------------
int Pausa2 = 1;
int modo_Media_temperatura = 0;
float temperaturas[100];
float suma = 0;
float m = 0;
int i = 0;

// -------------------- ULTRASONIC ---------------------
const int trigPin = 4;
const int echoPin = 5;
float duration;
float distance;

// DHT values
float t, h;

//Errores
bool esperandoTimeout = true;
bool fallo_TyH = 0;
bool fallo_tiempo = 0;
bool fallo_cerca = 0;
bool fallo_ultra = 0;

//Temperaturas_media
#define N_MEDIA 10
float bufferTemp[N_MEDIA];
int idxTemp = 0;
int numTemp = 0;
float sumaTemp = 0;
float mediaTemp = NAN;

// -------------------- SERIAL -------------------------
String input = "";
SoftwareSerial mySerial(10, 11);  // RX, TX
// Before Setup Se crea una funcion para enviar todos los datos de una


float leerDistancia() {
  long duracion;
  float distancia = -1;

  for (int intento = 0; intento < 3; intento++) {
    digitalWrite(trigPin, LOW);
    delayMicroseconds(3);
    digitalWrite(trigPin, HIGH);
    delayMicroseconds(10);
    digitalWrite(trigPin, LOW);

    duracion = pulseIn(echoPin, HIGH, 30000);
    if (duracion > 0) {
      distancia = duracion * 0.0343 / 2.0;
      if (distancia > 2 && distancia < 400) {
        return distancia;
      }
    }
  }
  return -1;
}
//Funciones checksum

// ======================================================
//                        SETUP
// ======================================================
void setup() {
  Serial.begin(9600);
  mySerial.begin(9600);

  // timers
  nextMillis1 = millis() + interval1;
  nextMillis2 = millis() + interval2;
  nextImpresion = millis() + intervaloImpresion;

  // DHT
  dht.begin();

  // Servo
  servoMotor.attach(6);
  servoMotor.write(angulo);

  // Ultrasonic
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);

  // Orbit simulation setup
  r = R_EARTH + ALTITUDE;
  real_orbital_period = 2 * PI * sqrt(pow(r, 3) / (G * M));
  nextUpdate = MILLIS_BETWEEN_UPDATES;
}

// ======================================================
//                         LOOP
// ======================================================
void loop() {

  // --------------------------------------------------
  //  SENSOR + DATA SENDING  every interval1
  // --------------------------------------------------
  if (Pausa2 == 0 && millis() >= nextMillis1) {
    h = dht.readHumidity();
    t = dht.readTemperature();

    if (isnan(h) || isnan(t)) {  // Si H o T son NaN, empieza un temporizador para dar error
      esperandoTimeout = true;
      Serial.print("Error");
    } else {
      esperandoTimeout = false;
      fallo_TyH = 0;  // En caso de que el fallo estuviera activo, se desactiva
      nextTimeoutHT = millis() + 5000;
      
      // -------- MEDIA MOVIL CORRECTA --------
      if (modo_Media_temperatura == 1) {
        sumaTemp -= bufferTemp[idxTemp];
        bufferTemp[idxTemp] = t;
        sumaTemp += t;

        idxTemp = (idxTemp + 1) % N_MEDIA;
        if (numTemp < N_MEDIA) numTemp++;

        mediaTemp = sumaTemp / numTemp;
      }

      // media móvil 10 valores
      if (modo_Media_temperatura == 1) {

        if (i > 9) {
          suma = suma + temperaturas[i] - temperaturas[(i - 9)];
          m = suma / 10.0;
        } else {
          suma += temperaturas[i];
          m = suma / 10.0;
        }
      }
      mySerial.print("TEMP:");
      mySerial.println(t);  // Se envian T, H, y la media a la estacion de tierra
      mySerial.print("HUM:");
      mySerial.println(h);

      if (modo_Media_temperatura == 1) {
        mySerial.print("MED:");
        mySerial.println(mediaTemp);
      } else {
        mySerial.print("MED:NaN");
      }

      i++;  // Pasa al siguiente instante de temperatura
    }
    nextMillis1 = millis() + interval1;
  }

  //---------------------------------------------------
  //      2. Activador de alarma de T y H
  // --------------------------------------------------
  if (esperandoTimeout && (millis() >= nextTimeoutHT)) {
    fallo_TyH = 1;  // Aquí sí se activa la alarma
      
    mySerial.print("Ar:");
    mySerial.println(fallo_TyH);
    
  } else {
    fallo_TyH = 0;
    mySerial.print("Ar:");
    mySerial.println(fallo_TyH);
    nextTimeoutHT = millis() + interval1;
  }                

  // --------------------------------------------------
  //      3. Actualización de simulador de la orbita
  // --------------------------------------------------
  unsigned long currentTime = millis();
  if (currentTime > nextUpdate) {
    simulate_orbit(currentTime, 0, 0);
    nextUpdate = currentTime + MILLIS_BETWEEN_UPDATES;
  }

  // --------------------------------------------------
  //          4. Lógica del Servomotor
  // --------------------------------------------------

  //          4'1. Modo automatico del servo (RASTREO SUAVE)
  if (aut == 1) {
    if (millis() - lastServoMove >= servoSpeed) {
        if (angulo >= 180) sentido = 0; // Cambiar a decrementar
        else if (angulo <= 0) sentido = 1; // Cambiar a incrementar

        if (sentido == 0) angulo -= 1;
        else angulo += 1;

        lastServoMove = millis();
    }
  }
  // El modo 'aut = 0' se mantiene en el último ángulo fijado por el modo 'aut = 1'
  // o por el comando serial '5'.
  
  // --------------------------------------------------
  //                  Mover el Servomotor
  // --------------------------------------------------
  servoMotor.write(angulo);


  // ---- SENSOR ULTRASONICO ----
  if (Pausa2 == 0 && millis() >= nextMillis2) {
    distance = leerDistancia();  //Detetca si hay un error y si no envia distancia
    if (distance == -1) {
      Serial.println("Lectura ultrasónica inválida");
      fallo_cerca = 0;  
      fallo_ultra = 1;
    } else if (distance < 10) {
      fallo_cerca = 1;
      fallo_ultra = 0;
    } else {
      fallo_cerca = 0;
      fallo_ultra = 0;
    }
    mySerial.print("DIST:");
    mySerial.println(distance);
    mySerial.print("ANG:");
    mySerial.println(angulo); // Enviar el ángulo real actual del servo
    
    // servoMotor.write(angulo); <-- ESTO SE HA ELIMINADO DE AQUÍ
    
    nextMillis2 = millis() + interval2;
  }

  if (Pausa2 == 0 && millis() >= nextMillis3) {
    mySerial.print("X:");
    mySerial.println(orbX);
    mySerial.print("Y:");
    mySerial.println(orbY);
    nextMillis3 = millis() + interval3;
  }

  // --------------------------------------------------
  //                SERIAL COMMANDS (MEJORADO)
  // --------------------------------------------------
  static String rxBuffer = "";

  while (mySerial.available()) {
    char c = mySerial.read();

    if (c == '\n') {
      rxBuffer.trim();
      Serial.println("RX: " + rxBuffer);

      int colon = rxBuffer.indexOf(':');
      if (colon == -1) {
        Serial.println("Formato inválido");
        rxBuffer = "";
        break;
      }

      String label = rxBuffer.substring(0, colon);
      String valueStr = rxBuffer.substring(colon + 1);
      valueStr.trim();

      // -------------------------------
      //        SWITCH BY LABEL
      // -------------------------------
      if (label == "1") {  // Cambio de modo de transmision (Pausa2)
        Pausa2 = valueStr.toInt();
      } else if (label == "2") {  // Cambio de calculador de media (modo_Media_temperatura)
        modo_Media_temperatura = valueStr.toInt();
      } else if (label == "AUT") { // Cambio de modo de Servomotor (aut)
        aut = valueStr.toInt();
      } else if (label == "5") {  // Angulo insertado manualmente (fija el ángulo y pasa a modo manual/fijo)
        angulo = constrain(valueStr.toInt(), 0, 180);
        aut = 0; // Desactiva el modo automático de rastreo
      } else if (label == "3") {  // Cambio del periodo de envio de temperatura y humedad
        interval1 = valueStr.toInt() * 1000UL;
      } else if (label == "4") {  // Cambio del periodo de envio de distancia
        interval2 = valueStr.toInt() * 1000UL;
      }

      rxBuffer = "";  // limpiar buffer
    } else {
      rxBuffer += c;
      if (rxBuffer.length() > 50) rxBuffer = "";  // protección overflow
    }
  }
}


// ======================================================
//                  ORBIT SIMULATION FUNC
// ======================================================
void simulate_orbit(unsigned long millis, double inclination, int ecef) {  //simula la orbita

  double time = (millis / 1000) * TIME_COMPRESSION;
  double angle = 2 * PI * (time / real_orbital_period);

  orbX = r * cos(angle);
  orbY = r * sin(angle) * cos(inclination);
  orbZ = r * sin(angle) * sin(inclination);

  if (ecef) {
    double theta = EARTH_ROTATION_RATE * time;
    double x_ecef = orbX * cos(theta) - orbY * sin(theta);
    double y_ecef = orbX * sin(theta) + orbY * cos(theta);
    orbX = x_ecef;
    orbY = y_ecef;
  }
}
